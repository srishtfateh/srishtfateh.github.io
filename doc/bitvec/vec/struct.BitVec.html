<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A compact `Vec` of bits, whose order and storage type can be customized."><meta name="keywords" content="rust, rustlang, rust-lang, BitVec"><title>BitVec in bitvec::vec - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">BitVec</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.add_assign_reverse">add_assign_reverse</a></li><li><a href="#method.add_reverse">add_reverse</a></li><li><a href="#method.append">append</a></li><li><a href="#method.as_bitslice">as_bitslice</a></li><li><a href="#method.as_mut_bitslice">as_mut_bitslice</a></li><li><a href="#method.as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.capacity">capacity</a></li><li><a href="#method.change_order">change_order</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.drain">drain</a></li><li><a href="#method.extend_from_slice">extend_from_slice</a></li><li><a href="#method.force_align">force_align</a></li><li><a href="#method.from_bitslice">from_bitslice</a></li><li><a href="#method.from_boxed_bitslice">from_boxed_bitslice</a></li><li><a href="#method.from_element">from_element</a></li><li><a href="#method.from_raw_parts">from_raw_parts</a></li><li><a href="#method.from_slice">from_slice</a></li><li><a href="#method.from_vec">from_vec</a></li><li><a href="#method.insert">insert</a></li><li><a href="#method.into_boxed_bitslice">into_boxed_bitslice</a></li><li><a href="#method.into_boxed_slice">into_boxed_slice</a></li><li><a href="#method.into_vec">into_vec</a></li><li><a href="#method.new">new</a></li><li><a href="#method.pop">pop</a></li><li><a href="#method.push">push</a></li><li><a href="#method.remove">remove</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.reserve">reserve</a></li><li><a href="#method.reserve_exact">reserve_exact</a></li><li><a href="#method.resize">resize</a></li><li><a href="#method.resize_with">resize_with</a></li><li><a href="#method.retain">retain</a></li><li><a href="#method.set_elements">set_elements</a></li><li><a href="#method.set_len">set_len</a></li><li><a href="#method.shrink_to_fit">shrink_to_fit</a></li><li><a href="#method.splice">splice</a></li><li><a href="#method.split_off">split_off</a></li><li><a href="#method.swap_remove">swap_remove</a></li><li><a href="#method.truncate">truncate</a></li><li><a href="#method.with_capacity">with_capacity</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#deref-methods-BitSlice%3CO%2C%20T%3E">Methods from Deref&lt;Target=BitSlice&lt;O, T&gt;&gt;</a></h3><ul><li><a href="#method.add_assign_reverse">add_assign_reverse</a></li><li><a href="#method.align_to">align_to</a></li><li><a href="#method.align_to_mut">align_to_mut</a></li><li><a href="#method.all">all</a></li><li><a href="#method.any">any</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.as_total_slice">as_total_slice</a></li><li><a href="#method.at">at</a></li><li><a href="#method.at_unchecked">at_unchecked</a></li><li><a href="#method.chunks">chunks</a></li><li><a href="#method.chunks_exact">chunks_exact</a></li><li><a href="#method.chunks_exact_mut">chunks_exact_mut</a></li><li><a href="#method.chunks_mut">chunks_mut</a></li><li><a href="#method.clone_from_slice">clone_from_slice</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.copy_from_slice">copy_from_slice</a></li><li><a href="#method.count_ones">count_ones</a></li><li><a href="#method.count_zeros">count_zeros</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.first">first</a></li><li><a href="#method.first_mut">first_mut</a></li><li><a href="#method.for_each">for_each</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_mut">iter_mut</a></li><li><a href="#method.last">last</a></li><li><a href="#method.last_mut">last_mut</a></li><li><a href="#method.len">len</a></li><li><a href="#method.not_all">not_all</a></li><li><a href="#method.not_any">not_any</a></li><li><a href="#method.rchunks">rchunks</a></li><li><a href="#method.rchunks_exact">rchunks_exact</a></li><li><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a></li><li><a href="#method.rchunks_mut">rchunks_mut</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.rotate_left">rotate_left</a></li><li><a href="#method.rotate_right">rotate_right</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_mut">rsplit_mut</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.rsplitn_mut">rsplitn_mut</a></li><li><a href="#method.set">set</a></li><li><a href="#method.set_all">set_all</a></li><li><a href="#method.set_unchecked">set_unchecked</a></li><li><a href="#method.some">some</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_mut_unchecked">split_at_mut_unchecked</a></li><li><a href="#method.split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_first">split_first</a></li><li><a href="#method.split_first_mut">split_first_mut</a></li><li><a href="#method.split_last">split_last</a></li><li><a href="#method.split_last_mut">split_last_mut</a></li><li><a href="#method.split_mut">split_mut</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.splitn_mut">splitn_mut</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.swap">swap</a></li><li><a href="#method.swap_unchecked">swap_unchecked</a></li><li><a href="#method.swap_with_slice">swap_with_slice</a></li><li><a href="#method.to_vec">to_vec</a></li><li><a href="#method.windows">windows</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Add%3CBitVec%3CO%2C%20T%3E%3E">Add&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-AddAssign%3CBitVec%3CO%2C%20T%3E%3E">AddAssign&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-AsMut%3C%5BT%5D%3E">AsMut&lt;[T]&gt;</a></li><li><a href="#impl-AsMut%3CBitSlice%3CO%2C%20T%3E%3E">AsMut&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-AsRef%3C%5BT%5D%3E">AsRef&lt;[T]&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E">AsRef&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Binary">Binary</a></li><li><a href="#impl-BitAnd%3CI%3E">BitAnd&lt;I&gt;</a></li><li><a href="#impl-BitAndAssign%3CI%3E">BitAndAssign&lt;I&gt;</a></li><li><a href="#impl-BitField">BitField</a></li><li><a href="#impl-BitOr%3CI%3E">BitOr&lt;I&gt;</a></li><li><a href="#impl-BitOrAssign%3CI%3E">BitOrAssign&lt;I&gt;</a></li><li><a href="#impl-BitXor%3CI%3E">BitXor&lt;I&gt;</a></li><li><a href="#impl-BitXorAssign%3CI%3E">BitXorAssign&lt;I&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CO%2C%20T%3E%3E">Borrow&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20T%3E%3E">BorrowMut&lt;BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-Default">Default</a></li><li><a href="#impl-Deref">Deref</a></li><li><a href="#impl-DerefMut">DerefMut</a></li><li><a href="#impl-Display">Display</a></li><li><a href="#impl-Drop">Drop</a></li><li><a href="#impl-Eq">Eq</a></li><li><a href="#impl-Extend%3Cbool%3E">Extend&lt;bool&gt;</a></li><li><a href="#impl-From%3C%26%27_%20%5BT%5D%3E">From&lt;&amp;&#39;_ [T]&gt;</a></li><li><a href="#impl-From%3C%26%27_%20%5Bbool%5D%3E">From&lt;&amp;&#39;_ [bool]&gt;</a></li><li><a href="#impl-From%3C%26%27_%20BitSlice%3CO%2C%20T%3E%3E">From&lt;&amp;&#39;_ BitSlice&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitBox%3CO%2C%20T%3E%3E">From&lt;BitBox&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBitVec%3CO%2C%20T%3E%3E">From&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-From%3CBox%3C%5BT%5D%2C%20Global%3E%3E">From&lt;Box&lt;[T], Global&gt;&gt;</a></li><li><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E">From&lt;Vec&lt;T, Global&gt;&gt;</a></li><li><a href="#impl-FromIterator%3Cbool%3E">FromIterator&lt;bool&gt;</a></li><li><a href="#impl-Hash">Hash</a></li><li><a href="#impl-Index%3CRange%3Cusize%3E%3E">Index&lt;Range&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E">Index&lt;RangeFrom&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeFull%3E">Index&lt;RangeFull&gt;</a></li><li><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E">Index&lt;RangeInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E">Index&lt;RangeTo&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E">Index&lt;RangeToInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-Index%3Cusize%3E">Index&lt;usize&gt;</a></li><li><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E">IndexMut&lt;Range&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E">IndexMut&lt;RangeFrom&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeFull%3E">IndexMut&lt;RangeFull&gt;</a></li><li><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E">IndexMut&lt;RangeInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E">IndexMut&lt;RangeTo&lt;usize&gt;&gt;</a></li><li><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E">IndexMut&lt;RangeToInclusive&lt;usize&gt;&gt;</a></li><li><a href="#impl-Into%3CBox%3C%5BT%5D%2C%20Global%3E%3E">Into&lt;Box&lt;[T], Global&gt;&gt;</a></li><li><a href="#impl-Into%3CVec%3CT%2C%20Global%3E%3E">Into&lt;Vec&lt;T, Global&gt;&gt;</a></li><li><a href="#impl-IntoIterator">IntoIterator</a></li><li><a href="#impl-LowerHex">LowerHex</a></li><li><a href="#impl-Neg">Neg</a></li><li><a href="#impl-Not">Not</a></li><li><a href="#impl-Octal">Octal</a></li><li><a href="#impl-Ord">Ord</a></li><li><a href="#impl-PartialEq%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E">PartialEq&lt;&amp;&#39;_ BitSlice&lt;C, D&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitSlice%3CC%2C%20D%3E%3E">PartialEq&lt;BitSlice&lt;C, D&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E">PartialEq&lt;BitVec&lt;C, D&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E">PartialOrd&lt;&amp;&#39;_ BitSlice&lt;C, D&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitSlice%3CC%2C%20D%3E%3E">PartialOrd&lt;BitSlice&lt;C, D&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E">PartialOrd&lt;BitVec&lt;C, D&gt;&gt;</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Shl%3Cusize%3E">Shl&lt;usize&gt;</a></li><li><a href="#impl-ShlAssign%3Cusize%3E">ShlAssign&lt;usize&gt;</a></li><li><a href="#impl-Shr%3Cusize%3E">Shr&lt;usize&gt;</a></li><li><a href="#impl-ShrAssign%3Cusize%3E">ShrAssign&lt;usize&gt;</a></li><li><a href="#impl-Sub%3CBitVec%3CO%2C%20T%3E%3E">Sub&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-SubAssign%3CBitVec%3CO%2C%20T%3E%3E">SubAssign&lt;BitVec&lt;O, T&gt;&gt;</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-UpperHex">UpperHex</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In bitvec::vec</a></h2><div id="sidebar-vars" data-name="BitVec" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">vec</a>::<wbr><a class="struct" href="#">BitVec</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/bitvec/vec.rs.html#249-257">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(C)]</div>pub struct BitVec&lt;O&nbsp;=&nbsp;<a class="type" href="../order/type.Local.html" title="type bitvec::order::Local">Local</a>, T&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span> { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A compact <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> of bits, whose order and storage type can be customized.</p>
<p><code>BitVec</code> is a newtype wrapper over <code>Vec</code>, and as such is exactly three words in
size on the stack.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec::new</span>();
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>[<span class="number">0</span>], <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">1</span>);

<span class="ident">bv</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>[<span class="number">0</span>], <span class="bool-val">true</span>);

<span class="ident">bv</span>.<span class="ident">extend</span>([<span class="number">0u8</span>, <span class="number">1</span>, <span class="number">0</span>].<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">n</span> <span class="op">!</span><span class="op">=</span> <span class="number">0u8</span>));
<span class="kw">for</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">bv</span> {
  <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bit</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
<p>The <a href="../macro.bitvec.html"><code>bitvec!</code></a> macro is provided to make initialization more convenient.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
<p>It can also initialize each element of a <code>BitVec&lt;_, T&gt;</code> with a given value. This
may be more efficient than performing allocation and initialization in separate
steps, especially when initializing a vector of zeros:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">15</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="comment">// The following is equivalent, but potentially slower:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv1</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec::with_capacity</span>(<span class="number">15</span>);
<span class="ident">bv1</span>.<span class="ident">resize</span>(<span class="number">15</span>, <span class="bool-val">false</span>);</code></pre></div>
<p>Use a <code>BitVec&lt;T&gt;</code> as an efficient stack:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stack</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec::new</span>();

<span class="ident">stack</span>.<span class="ident">push</span>(<span class="bool-val">false</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);

<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">top</span>) <span class="op">=</span> <span class="ident">stack</span>.<span class="ident">pop</span>() {
  <span class="comment">//  Prints true, true, false</span>
  <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">top</span>);
}</code></pre></div>
<h2 id="indexing"><a href="#indexing">Indexing</a></h2>
<p>The <code>BitVec</code> type allows you to access values by index, because it implements
the <a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code>Index</code></a> trait. An example will be more explicit:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>[<span class="number">1</span>]); <span class="comment">// it will display &#39;false&#39;</span></code></pre></div>
<p>However, be careful: if you try to access an index which isn’t in the <code>BitVec</code>,
your software will panic! You cannot do this:</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>[<span class="number">6</span>]); <span class="comment">// it will panic!</span></code></pre></div>
<p>In conclusion: always check if the index you want to get really exists before
doing it.</p>
<h2 id="slicing"><a href="#slicing">Slicing</a></h2>
<p>A <code>BitVec</code> is growable. A <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a>, on the other hand, is fixed size. To get
a bit slice, use <code>&amp;</code>. Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">fn</span> <span class="ident">read_bitslice</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span>) {
    <span class="comment">// use slice</span>
}

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>];
<span class="ident">read_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">bv</span>);

<span class="comment">// … and that’s all!</span>
<span class="comment">// you can also do it like this:</span>
<span class="kw">let</span> <span class="ident">bs</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">bv</span>;</code></pre></div>
<p>In Rust, it’s more common to pass slices as arguments rather than vectors when
you do not want to grow or shrink it. The same goes for <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> and [<code>&amp;[]</code>], and
<a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code>String</code></a> and <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code>&amp;str</code></a>.</p>
<h2 id="capacity-and-reallocation"><a href="#capacity-and-reallocation">Capacity and reallocation</a></h2>
<p>The capacity of a bit vector is the amount of space allocated for any future
bits that will be added onto the vector. This is not to be confused with the
<em>length</em> of a vector, which specifies the number of live, useful bits within the
vector. If a vector’s length exceeds its capacity, its capacity will
automatically be increased, but its storage elements will have to be
reallocated.</p>
<p>For example, a bit vector with capacity 10 and length 0 would be an allocated,
but uninhabited, vector, with space for ten more bits. Pushing ten or fewer bits
onto the vector will not change its capacity or cause reallocation to occur.
However, if the vector’s length is increased to eleven, it will have to
reallocate, which can be slow. For this reason, it is recommended to use
<a href="#method.with_capacity"><code>BitVec::with_capacity</code></a> whenever possible to specify how big the bit vector is
expected to get.</p>
<h2 id="guarantees"><a href="#guarantees">Guarantees</a></h2>
<p>Due to its incredibly fundamental nature, <code>BitVec</code> makes a lot of guarantees
about its design. This ensures that it is as low-overhead as possible in the
general case, and can be correctly manipulated in fundamental ways by <code>unsafe</code>
code.</p>
<p>Most fundamentally, <code>BitVec</code> is and always will be a <code>([</code>BitPtr<code>], capacity)</code>
doublet. No more, no less. The order of these fields is unspecified, and you
should <strong>only</strong> interact with the members through the provided APIs. Note that
<code>BitPtr</code> is <em><strong>not directly manipulable</strong></em>, and must <em><strong>never</strong></em> be written or
interpreted as anything but opaque binary data by user code.</p>
<p>When a <code>BitVec</code> has allocated memory, then the memory to which it points is on
the heap (as defined by the allocator Rust is configured to use by default), and
its pointer points to <a href="#method.len"><code>len</code></a> initialized bits in order of the <a href="../order/trait.BitOrder.html"><code>BitOrder</code></a> type
parameter, followed by <code>capacity - len</code> logically uninitialized bits.</p>
<p><code>BitVec</code> will never perform a “small optimization” where elements are stored in
its handle representation, for two reasons:</p>
<ul>
<li>
<p>It would make it more difficult for user code to correctly manipulate a
<code>BitVec</code>. The contents of the <code>BitVec</code> would not have a stable address if the
handle were moved, and it would be more difficult to determine if a <code>BitVec</code>
had allocated memory.</p>
</li>
<li>
<p>It would penalize the general, heap-allocated, case by incurring a branch on
every access.</p>
</li>
</ul>
<p><code>BitVec</code> will never automatically shrink itself, even if it is emptied. This
ensures that no unnecessary allocations or deallocations occur. Emptying a
<code>BitVec</code> and then refilling it to the same length will incur no calls to the
allocator. If you wish to free up unused memory, use <a href="#method.shrink_to_fit"><code>shrink_to_fit</code></a>.</p>
<h3 id="erasure"><a href="#erasure">Erasure</a></h3>
<p><code>BitVec</code> will not specifically overwrite any data that is removed from it, nor
will it specifically preserve it. Its uninitialized memory is scratch space that
may be used however the implementation desires, and must not be relied upon as
stable. Do not rely on removed data to be erased for security purposes. Even if
you drop a <code>BitVec</code>, its buffer may simply be reused for other data structures
in your program. Even if you zero a <code>BitVec</code>’s memory first, that may not
actually occur if the optimizer does not consider this an observable side
effect. There is one case that will never break, however: using <code>unsafe</code> to
construct a <code>[T]</code> slice over the <code>BitVec</code>’s capacity, and writing to the excess
space, then increasing the length to match, is always valid.</p>
<h2 id="type-parameters"><a href="#type-parameters">Type Parameters</a></h2>
<ul>
<li><code>O: BitOrder</code>: An implementor of the <a href="../order/trait.BitOrder.html"><code>BitOrder</code></a> trait. This type is used to
convert semantic indices into concrete bit positions in elements, and store or
retrieve bit values from the storage type.</li>
<li><code>T: BitStore</code>: An implementor of the <a href="../store/trait.BitStore.html"><code>BitStore</code></a> trait: <code>u8</code>, <code>u16</code>, <code>u32</code>,
or <code>u64</code> (64-bit systems only). This is the actual type in memory that the
vector will use to store data.</li>
</ul>
<h2 id="safety"><a href="#safety">Safety</a></h2>
<p>The <code>BitVec</code> handle has the same <em>size</em> as standard Rust <code>Vec</code> handles, but it
is <em><strong>extremely binary incompatible</strong></em> with them. Attempting to treat
<code>BitVec&lt;_, T&gt;</code> as <code>Vec&lt;T&gt;</code> in any manner except through the provided APIs is
<em><strong>catastrophically</strong></em> unsafe and unsound.</p>
<p>[<code>&amp;[]</code>]: https://doc.rust-lang.org/stable/std/primitive.slice.html</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#23-819">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#34-36">source</a></span><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new, empty <code>BitVec&lt;C, T&gt;</code>.</p>
<p>The vector will not allocate until elements are pushed onto it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitVec::new</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.with_capacity" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#49-63">source</a></span><a href="#method.with_capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.with_capacity" class="fnname">with_capacity</a>(capacity: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a new, empty <code>BitVec&lt;C, T&gt;</code> with the specified capacity.</p>
<p>The vector will be able to hold at least <code>capacity</code> bits without
reallocating. If <code>capacity</code> is 0, the vector will not allocate.</p>
<p>It is important to note that although the returned vector has the
<em>capacity</em> specified, the vector will have a zero <em>length</em>. For an
explanation of the difference between length and capacity, see
<a href="#capacity-and-reallocation"><em>Capacity and reallocation</em></a>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capacity" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#74-78">source</a></span><a href="#method.capacity" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.capacity" class="fnname">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits the vector can hold without reallocating.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitVec::with_capacity</span>(<span class="number">100</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reserve" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#98-110">source</a></span><a href="#method.reserve" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reserve" class="fnname">reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves capacity for at least <code>additional</code> more bits to be inserted in
the given <code>BitVec&lt;C, T&gt;</code>. The collection may reserve more space to avoid
frequent reallocations. After calling <code>reserve</code>, the capacity will be
greater than or equal to <code>self.len() + additional</code>. Does nothing if the
capacity is already sufficient.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if the new capacity overflows <code>BitPtr::&lt;T&gt;::MAX_BITS</code>.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">reserve</span>(<span class="number">10</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">11</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reserve_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#133-144">source</a></span><a href="#method.reserve_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fnname">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves the minimum capacity for exactly <code>additional</code> more bits to be
inserted in the given <code>BitVec&lt;C, T&gt;</code>. After calling <code>reserve_exact</code>,
capacity will be greater than or equal to <code>self.len() + additional</code>.
Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if the new capacity overflows <code>BitPtr::&lt;T&gt;::MAX_BITS</code>.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">reserve_exact</span>(<span class="number">10</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">11</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#162-164">source</a></span><a href="#method.shrink_to_fit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fnname">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Shrinks the capacity of the vector as much as possible.</p>
<p>It will drop down as close as possible to the length but the allocator
may still inform the vector that there is space for a few more elements.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitVec::with_capacity</span>(<span class="number">10</span>);
<span class="ident">bv</span>.<span class="ident">extend</span>([<span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>].<span class="ident">iter</span>().<span class="ident">copied</span>());
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">10</span>);
<span class="ident">bv</span>.<span class="ident">shrink_to_fit</span>();
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_boxed_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#200-202">source</a></span><a href="#method.into_boxed_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_boxed_slice" class="fnname">into_boxed_slice</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>&gt;</h4></section></summary><div class="docblock"><p>Converts the bit-vector into [<code>Box&lt;[T]&gt;</code>].</p>
<p>Note that this will drop any excess capacity.</p>
<p>For the vec-to-box equivalent that produces a <a href="../boxed/struct.BitBox.html"><code>BitBox&lt;C, T&gt;</code></a>, see
[<code>into_boxed_bitslice</code>].</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">into_boxed_slice</span>();</code></pre></div>
<p>Any excess capacity is removed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::with_capacity</span>(<span class="number">100</span>);
<span class="ident">bv</span>.<span class="ident">extend</span>([<span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>].<span class="ident">iter</span>().<span class="ident">copied</span>());

<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">100</span>);
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">into_boxed_slice</span>();
<span class="kw">let</span> <span class="ident">boxed_bitslice</span> <span class="op">=</span> <span class="ident">BitBox</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::from_boxed_slice</span>(<span class="ident">slice</span>);
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec::from_boxed_bitslice</span>(<span class="ident">boxed_bitslice</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">capacity</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">3</span>);</code></pre></div>
<p>[<code>Box&lt;[T]&gt;</code>]: https://doc.rust-lang.org/std/boxed/struct.Box.html
[<code>into_boxed_bitslice</code>]: #method.into_boxed_bitslice</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.truncate" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#245-249">source</a></span><a href="#method.truncate" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.truncate" class="fnname">truncate</a>(&amp;mut self, len: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shortens the vector, keeping the first <code>len</code> bits and dropping the rest.</p>
<p>If <code>len</code> is greater than the vector’s current length, this has no
effect.</p>
<p>The [<code>drain</code>] method can emulate <code>truncate</code>, but causes the excess bits
to be returned instead of dropped.</p>
<p>Note that this method has no effect on the allocated capacity of the
vector.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<p>Truncating a five-bit vector to two bits:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">truncate</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
<p>No truncation occurs when <code>len</code> is greater than the vector’s current
length:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">5</span>];
<span class="ident">bv</span>.<span class="ident">truncate</span>(<span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">5</span>]);</code></pre></div>
<p>Truncating to zero is equivalent to calling the [<code>clear</code>] method.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">5</span>];
<span class="ident">bv</span>.<span class="ident">truncate</span>(<span class="number">0</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#269-271">source</a></span><a href="#method.as_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_slice" class="fnname">as_slice</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Extracts an element slice containing the entire vector.</p>
<p>Unlike <a href="../slice/struct.BitSlice.html#method.as_slice"><code>BitSlice::as_slice</code></a>, this will produce partial edge elements,
as they are known to not be aliased by any other slice handles.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>::{<span class="self">self</span>, <span class="ident">Write</span>};
<span class="kw">let</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Local</span>, <span class="ident">u8</span>; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">io::sink</span>().<span class="ident">write</span>(<span class="ident">buffer</span>.<span class="ident">as_slice</span>()).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#292-294">source</a></span><a href="#method.as_mut_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_slice" class="fnname">as_mut_slice</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;mut [T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Extracts a mutable slice of the entire vector.</p>
<p>Unlike <a href="../slice/struct.BitSlice.html#method.as_mut_slice"><code>BitSlice::as_mut_slice</code></a>, this will produce partial edge
elements, as they are known to not be aliased by any other slice
handles.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>::{<span class="self">self</span>, <span class="ident">Read</span>};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Local</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">24</span>];
<span class="ident">io::repeat</span>(<span class="number">0xA5u8</span>).<span class="ident">read_exact</span>(<span class="ident">buffer</span>.<span class="ident">as_mut_slice</span>()).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_len" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#324-339">source</a></span><a href="#method.set_len" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.set_len" class="fnname">set_len</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Forces the length of the vector to <code>new_len</code>.</p>
<p>This is a low-level operation that maintains none of the normal
invariants of the type. Normally changing the length of a vector is done
using one of the safe operations instead, such as [<code>truncate</code>],
[<code>resize</code>], [<code>extend</code>], or [<code>clear</code>].</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<ul>
<li><code>new_len</code> must be less than or equal to [<code>capacity()</code>].</li>
<li>The underlying elements at <code>old_len ..new_len</code> must be initialized.</li>
</ul>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<p>This method can be useful for situations in which the vector is serving
as a buffer for other code, particularly over FFI.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::with_capacity</span>(<span class="number">17</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="kw">unsafe</span> { <span class="ident">bv</span>.<span class="ident">set_len</span>(<span class="number">23</span>) };
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">23</span>);</code></pre></div>
<p>This example executes correctly, because the allocator can only reserve
even multiples of bytes, and so rounds up from the <code>with_capacity</code>
argument.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_remove" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#363-369">source</a></span><a href="#method.swap_remove" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap_remove" class="fnname">swap_remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes a bit from the vector and returns it.</p>
<p>The removed bit is replaced by the last bit of the vector.</p>
<p>This does not preserve ordering, but is O(1).</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Panics if <code>index</code> is out of bounds.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bv</span>.<span class="ident">swap_remove</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);

<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">swap_remove</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.insert" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#388-393">source</a></span><a href="#method.insert" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.insert" class="fnname">insert</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Inserts a bit at position <code>index</code> within the vector, shifting all bits
after it to the right.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>Panics if <code>index &gt; len</code>.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="ident">bv</span>.<span class="ident">insert</span>(<span class="number">4</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.remove" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#410-418">source</a></span><a href="#method.remove" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.remove" class="fnname">remove</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Removes and returns the bit at position <code>index</code> within the vector,
shifting all bits after it to the left.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>Panics if <code>index</code> is out of bounds.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bv</span>.<span class="ident">remove</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.retain" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#444-451">source</a></span><a href="#method.retain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.retain" class="fnname">retain</a>&lt;F&gt;(&amp;mut self, pred: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Retains only the bits that pass the predicate.</p>
<p>This removes all bits <code>b</code> where <code>f(e)</code> returns <code>false</code>. This method
operates in place and preserves the order of the retained bits. Because
it is in-place, it operates in <code>O(n²)</code> time.</p>
<h5 id="api-differences"><a href="#api-differences">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html#method.retain" title="Vec::retain"><code>Vec::retain</code></a> method takes a predicate function with signature
<code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has signature
<code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because <code>BitSlice</code> by
definition has only one bit of information per slice item, and including
the index allows the callback function to make more informed choices.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">retain</span>(<span class="op">|</span><span class="kw">_</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.push" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#472-491">source</a></span><a href="#method.push" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.push" class="fnname">push</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Appends a bit to the back of the vector.</p>
<p>If the vector is at capacity, this may cause a reallocation.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>This will panic if the push will cause the vector to allocate above
<code>BitPtr&lt;T&gt;::MAX_ELTS</code> or machine capacity.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec::new</span>();
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">1</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pop" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#510-516">source</a></span><a href="#method.pop" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.pop" class="fnname">pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Removes the last element from a vector and returns it, or <code>None</code> if it
is empty.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec::new</span>();
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">1</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>[<span class="number">0</span>]);

<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">pop</span>().<span class="ident">unwrap</span>());
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">pop</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.append" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#537-541">source</a></span><a href="#method.append" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.append" class="fnname">append</a>&lt;D, U&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;D, U&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>Panics if the number of bits in the vector overflows
<code>BitPtr::&lt;T&gt;::MAX_ELTS</code>.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv1</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">10</span>];
<span class="ident">bv1</span>.<span class="ident">append</span>(<span class="kw-2">&amp;mut</span> <span class="ident">bv2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv1</span>.<span class="ident">len</span>(), <span class="number">20</span>);
<span class="macro">assert!</span>(<span class="ident">bv1</span>[<span class="number">10</span>]);
<span class="macro">assert!</span>(<span class="ident">bv2</span>.<span class="ident">is_empty</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drain" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#570-602">source</a></span><a href="#method.drain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.drain" class="fnname">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Drain.html" title="struct bitvec::vec::Drain">Drain</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Creates a draining iterator that removes the specified range from the
vector and yields the removed bits.</p>
<h5 id="notes"><a href="#notes">Notes</a></h5>
<ol>
<li>The element range is removed even if the iterator is only partially
consumed or not consumed at all.</li>
<li>It is unspecified how many bits are removed from the vector if the
<code>Drain</code> value is leaked.</li>
</ol>
<h5 id="panics-7"><a href="#panics-7">Panics</a></h5>
<p>Panics if the starting point is greater than the end point or if the end
point is greater than the length of the vector.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">7</span>);
<span class="kw">for</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">bv</span>.<span class="ident">drain</span>(<span class="number">2</span> .. <span class="number">5</span>) {
  <span class="macro">assert!</span>(<span class="ident">bit</span>);
}
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">not_any</span>());
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clear" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#623-625">source</a></span><a href="#method.clear" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.clear" class="fnname">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears the vector, removing all values.</p>
<p>Note that this method has no effect on the allocated capacity of the
vector.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">30</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">30</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span><span class="ident">b</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">b</span>));
<span class="ident">bv</span>.<span class="ident">clear</span>();
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">is_empty</span>());</code></pre></div>
<p>After calling <code>clear()</code>, <code>bv</code> will no longer show raw memory, so the
above test cannot show that the underlying memory is not altered. This
is also an implementation detail on which you should not rely.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_off" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#647-659">source</a></span><a href="#method.split_off" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_off" class="fnname">split_off</a>(&amp;mut self, at: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Splits the collection into two at the given index.</p>
<p>Returns a newly allocated <code>Self</code>. <code>self</code> contains elements <code>[0, at)</code>,
and the returned <code>Self</code> contains elements <code>[at, len)</code>.</p>
<p>Note that the capacity of <code>self</code> does not change.</p>
<h5 id="panics-8"><a href="#panics-8">Panics</a></h5>
<p>Panics if <code>at &gt; len</code>.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv1</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="ident">bv1</span>.<span class="ident">split_off</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv1</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv2</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.resize_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#693-707">source</a></span><a href="#method.resize_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.resize_with" class="fnname">resize_with</a>&lt;F&gt;(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, the <code>BitVec</code> is extended by the
difference, with each additional slot filled with the result of calling
the closure <code>f</code>. The return values from <code>f</code> will end up in the <code>BitVec</code>
in the order they have been generated.</p>
<p>If <code>new_len</code> is less than <code>len</code>, the <code>BitVec</code> is simply truncated.</p>
<p>This method uses a closure to create new values on every push. If you’d
rather <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> a given value, use <a href="#method.resize"><code>resize</code></a>. If you want to use the
<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait to generate values, you can pass
<a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>Default::default()</code></a> as the second argument.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">resize_with</span>(<span class="number">5</span>, <span class="ident">Default::default</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">p</span> <span class="op">=</span> <span class="number">1</span>;
<span class="ident">bv</span>.<span class="ident">resize_with</span>(<span class="number">4</span>, <span class="op">|</span><span class="op">|</span> { <span class="ident">p</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>; <span class="ident">p</span> <span class="op">%</span> <span class="number">2</span> <span class="op">==</span> <span class="number">0</span>});
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.resize" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#725-737">source</a></span><a href="#method.resize" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.resize" class="fnname">resize</a>(&amp;mut self, new_len: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Resizes the <code>BitVec</code> in place so that <code>len</code> is equal to <code>new_len</code>.</p>
<p>If <code>new_len</code> is greater than <code>len</code>, the <code>BitVec</code> is extended by the
difference, with each additional slot filled with <code>value</code>. If <code>new_len</code>
is less than <code>len</code>, the <code>BitVec</code> is simply truncated.</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">4</span>];
<span class="ident">bv</span>.<span class="ident">resize</span>(<span class="number">8</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="ident">bv</span>.<span class="ident">resize</span>(<span class="number">5</span>, <span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_from_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#759-766">source</a></span><a href="#method.extend_from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.extend_from_slice" class="fnname">extend_from_slice</a>&lt;D, U&gt;(&amp;mut self, other: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;D, U&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Clones and appends all bits in a bit-slice to the <code>BitVec</code>.</p>
<p>Iterates over the bit-slice <code>other</code>, clones each bit, and then appends
it to this <code>BitVec</code>. The <code>other</code> slice is traversed in-order.</p>
<p>Note that this function is the same as <a href="#method.extend"><code>extend</code></a> except that it is
specialized to work with bit-slices instead. If and when Rust gets
specialization this function will likely be deprecated (but still
available).</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>];
<span class="ident">bv</span>.<span class="ident">extend_from_slice</span>(<span class="number">0xA5u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>());
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/api.rs.html#808-818">source</a></span><a href="#method.splice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splice" class="fnname">splice</a>&lt;R, I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;range: R, <br>&nbsp;&nbsp;&nbsp;&nbsp;replace_with: I<br>) -&gt; <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'_, O, T, &lt;I as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'a, O, T, I&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Splice.html" title="struct bitvec::vec::Splice">Splice</a>&lt;'a, O, T, I&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Creates a splicing iterator that replaces the specified range in the
vector with the given <code>replace_with</code> iterator and yields the removed
bits. <code>replace_with</code> does not need to be the same length as <code>range</code>.</p>
<h5 id="notes-1"><a href="#notes-1">Notes</a></h5>
<ol>
<li>
<p>The element range is removed and replaced even if the iterator
produced by this method is not consumed until the end.</p>
</li>
<li>
<p>It is unspecified how many bits are removed from the vector if the
<code>Splice</code> value is leaked.</p>
</li>
<li>
<p>The input iterator <code>replace_with</code> is only consumed when the <code>Splice</code>
value is dropped.</p>
</li>
<li>
<p>This is optimal if:</p>
<ul>
<li>the tail (elements in the vector after <code>range</code>) is empty,</li>
<li>or <code>replace_with</code> yields fewer bits than <code>range</code>’s length,</li>
<li>the lower bound of its <code>size_hint()</code> is exact.</li>
</ul>
<p>Otherwise, a temporary vector is allocated and the tail is moved
twice.</p>
</li>
</ol>
<h5 id="panics-9"><a href="#panics-9">Panics</a></h5>
<p>Panics if the starting point is greater than the end point or if the end
point is greater than the length of the vector.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<p>This example starts with six bits of zero, and then splices out bits 2
and 3 and replaces them with four bits of one.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let</span> <span class="ident">bv2</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">4</span>];

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">splice</span>(<span class="number">2</span> .. <span class="number">4</span>, <span class="ident">bv2</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">BitVec</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#259-835">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.repeat" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#274-279">source</a></span><a href="#method.repeat" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.repeat" class="fnname">repeat</a>(bit: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>, len: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a <code>BitVec</code> from a value repeated many times.</p>
<p>This function is equivalent to the <code>bitvec![O, T; bit; len]</code> macro call,
and is in fact the implementation of that macro syntax.</p>
<h5 id="parameters"><a href="#parameters">Parameters</a></h5>
<ul>
<li><code>bit</code>: The bit value to which all <code>len</code> allocated bits will be set.</li>
<li><code>len</code>: The number of live bits in the constructed <code>BitVec</code>.</li>
</ul>
<h5 id="returns"><a href="#returns">Returns</a></h5>
<p>A <code>BitVec</code> with <code>len</code> live bits, all set to <code>bit</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_element" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#302-306">source</a></span><a href="#method.from_element" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_element" class="fnname">from_element</a>(elt: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a <code>BitVec</code> from a single element.</p>
<p>The produced <code>BitVec</code> will span the element, and include all bits in it.</p>
<h5 id="parameters-1"><a href="#parameters-1">Parameters</a></h5>
<ul>
<li><code>elt</code>: The source element.</li>
</ul>
<h5 id="returns-1"><a href="#returns-1">Returns</a></h5>
<p>A <code>BitVec</code> over the provided element.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u8</span><span class="op">&gt;</span><span class="ident">::from_element</span>(<span class="number">5</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">count_ones</span>(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#333-335">source</a></span><a href="#method.from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_slice" class="fnname">from_slice</a>(slice: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[T]</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a <code>BitVec</code> from a slice of elements.</p>
<p>The produced <code>BitVec</code> will span the provided slice.</p>
<h5 id="parameters-2"><a href="#parameters-2">Parameters</a></h5>
<ul>
<li><code>slice</code>: The source elements to copy into the new <code>BitVec</code>.</li>
</ul>
<h5 id="returns-2"><a href="#returns-2">Returns</a></h5>
<p>A <code>BitVec</code> set to the provided slice values.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">5</span>, <span class="number">10</span>];
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u8</span><span class="op">&gt;</span><span class="ident">::from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[..]);
<span class="macro">assert!</span>(<span class="ident">bv</span>[<span class="number">5</span>]);
<span class="macro">assert!</span>(<span class="ident">bv</span>[<span class="number">7</span>]);
<span class="macro">assert!</span>(<span class="ident">bv</span>[<span class="number">12</span>]);
<span class="macro">assert!</span>(<span class="ident">bv</span>[<span class="number">14</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_vec" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#363-380">source</a></span><a href="#method.from_vec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_vec" class="fnname">from_vec</a>(vec: <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Consumes a <code>Vec&lt;T&gt;</code> and creates a <code>BitVec&lt;C, T&gt;</code> from it.</p>
<h5 id="parameters-3"><a href="#parameters-3">Parameters</a></h5>
<ul>
<li><code>vec</code>: The source vector whose memory will be used.</li>
</ul>
<h5 id="returns-3"><a href="#returns-3">Returns</a></h5>
<p>A new <code>BitVec</code> using the <code>vec</code> <code>Vec</code>’s memory.</p>
<h5 id="panics-10"><a href="#panics-10">Panics</a></h5>
<p>Panics if the source vector would cause the <code>BitVec</code> to overflow
capacity.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec</span>::<span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u8</span><span class="op">&gt;</span><span class="ident">::from_vec</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]);
<span class="macro">assert_eq!</span>(
  <span class="string">&quot;[00000001, 00000010, 00000100, 00001000]&quot;</span>,
  <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>),
);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#420-444">source</a></span><a href="#method.from_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_bitslice" class="fnname">from_bitslice</a>(slice: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Clones a <code>&amp;BitSlice</code> into a <code>BitVec</code>.</p>
<p>This is the only method by which a <code>BitVec</code> can be created whose first
live bit is not at the <code>0</code> position. This behavior, though
unconventional for common uses of <code>BitVec</code>, allows for a more efficient
clone of any <code>BitSlice</code> region without shifting each bit in the region
down to fit the <code>0</code> starting position.</p>
<p>Misaligned <code>BitVec</code>s <strong>do not</strong> have any adverse effect on usage other
than the in-memory representation.</p>
<p>Whenever a <code>BitVec</code> is emptied, its head index is always set to <code>0</code>, and
will begin from the aligned position on future refills.</p>
<p>The <a href="#method.force_align"><code>::force_align</code></a> method will shift the <code>BitVec</code>’s data to begin at
the <code>0</code> index, if you require this property.</p>
<h5 id="parameters-4"><a href="#parameters-4">Parameters</a></h5>
<ul>
<li><code>slice</code>: The source <code>BitSlice</code> region. This may have any head index,
and its memory will be copied element-wise into the new buffer.</li>
</ul>
<h5 id="returns-4"><a href="#returns-4">Returns</a></h5>
<p>A <code>BitVec</code> containing the same bits as the source slice.</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> [<span class="number">0u8</span>, <span class="op">!</span><span class="number">0</span>].<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec::from_bitslice</span>(<span class="ident">bs</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">16</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">some</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_boxed_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#467-471">source</a></span><a href="#method.from_boxed_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_boxed_bitslice" class="fnname">from_boxed_bitslice</a>(slice: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts a frozen <code>BitBox</code> allocation into a growable <code>BitVec</code>.</p>
<p>This does not copy or reallocate.</p>
<h5 id="parameters-5"><a href="#parameters-5">Parameters</a></h5>
<ul>
<li><code>slice</code>: A <code>BitBox</code> to be thawed.</li>
</ul>
<h5 id="returns-5"><a href="#returns-5">Returns</a></h5>
<p>A growable collection over the original memory of the slice.</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">BitVec::from_boxed_bitslice</span>(<span class="macro">bitbox!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="ident">bv</span>.<span class="ident">some</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_raw_parts" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#509-515">source</a></span><a href="#method.from_raw_parts" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_parts" class="fnname">from_raw_parts</a>(pointer: BitPtr&lt;T&gt;, capacity: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new <code>BitVec&lt;C, T&gt;</code> directly from the raw parts of another.</p>
<h5 id="parameters-6"><a href="#parameters-6">Parameters</a></h5>
<ul>
<li><code>pointer</code>: The <code>BitPtr&lt;T&gt;</code> to use.</li>
<li><code>capacity</code>: The number of <code>T</code> elements <em>allocated</em> in that slab.</li>
</ul>
<h5 id="returns-6"><a href="#returns-6">Returns</a></h5>
<p>A <code>BitVec</code> over the given slab of memory.</p>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>This is <em><strong>highly</strong></em> unsafe, due to the number of invariants that aren’t
checked:</p>
<ul>
<li><code>pointer</code> needs to have been previously allocated by some allocating
type.</li>
<li><code>pointer</code>’s <code>T</code> needs to have the same size <em><strong>and alignment</strong></em> as it
was initially allocated.</li>
<li><code>pointer</code>’s element count needs to be less than or equal to the
original allocation capacity.</li>
<li><code>capacity</code> needs to be the original allocation capacity for the
vector. This is <em>not</em> the value produced by <code>.capacity()</code>.</li>
</ul>
<p>Violating these <em><strong>will</strong></em> cause problems, like corrupting the handle’s
concept of memory, the allocator’s internal data structures, and the
sanity of your program. It is <em><strong>absolutely</strong></em> not safe to construct a
<code>BitVec</code> whose <code>T</code> differs from the type used for the initial
allocation.</p>
<p>The ownership of <code>pointer</code> is effectively transferred to the
<code>BitVec&lt;C, T&gt;</code> which may then deallocate, reallocate, or modify the
contents of the referent slice at will. Ensure that nothing else uses
the pointer after calling this function.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#538-540">source</a></span><a href="#method.as_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_bitslice" class="fnname">as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Produces a <code>BitSlice</code> containing the entire vector.</p>
<p>Equivalent to <code>&amp;s[..]</code>.</p>
<h5 id="parameters-7"><a href="#parameters-7">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-7"><a href="#returns-7">Returns</a></h5>
<p>A <code>BitSlice</code> over the vector.</p>
<h5 id="examples-29"><a href="#examples-29">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">as_bitslice</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#563-565">source</a></span><a href="#method.as_mut_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_bitslice" class="fnname">as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Produces a mutable <code>BitSlice</code> containing the entire vector.</p>
<p>Equivalent to <code>&amp;mut s[..]</code>.</p>
<h5 id="parameters-8"><a href="#parameters-8">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h5 id="returns-8"><a href="#returns-8">Returns</a></h5>
<p>A mutable <code>BitSlice</code> over the vector.</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">bs</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">as_mut_bitslice</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_elements" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#598-600">source</a></span><a href="#method.set_elements" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_elements" class="fnname">set_elements</a>(&amp;mut self, element: T)</h4></section></summary><div class="docblock"><p>Sets the backing storage to the provided element.</p>
<p>This unconditionally sets each live element in the backing buffer to the
provided value, without altering the <code>BitVec</code> length or capacity. It
operates on the underlying <code>Vec</code>’s memory buffer directly, and ignores
the <code>BitVec</code>’s cursors.</p>
<p>It is an implementation detail as to whether this affects the value of
allocated, but not currently used, elements in the buffer. Behavior of
this method on elements not visible through <code>self.as_slice()</code> is not
specified.</p>
<h5 id="parameters-9"><a href="#parameters-9">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>element</code>: The value to which each live element in the backing store
will be set.</li>
</ul>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Local</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">10</span>];
<span class="comment">//  note: the second element is not required to be zero, only to have</span>
<span class="comment">//  bits `0` and `1` according to `Local` be `0`.</span>
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0</span>);
<span class="ident">bv</span>.<span class="ident">set_elements</span>(<span class="number">0xA5</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0xA5</span>, <span class="number">0xA5</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_reverse" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#635-639">source</a></span><a href="#method.add_reverse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_reverse" class="fnname">add_reverse</a>&lt;I&gt;(self, addend: I) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Performs “reverse” addition (left to right instead of right to left).</p>
<p>This addition traverses the addends from left to right, performing
the addition at each index and writing the sum into <code>self</code>.</p>
<p>If <code>addend</code> expires before <code>self</code> does, <code>addend</code> is zero-extended and
the carry propagates through the rest of <code>self</code>. If <code>self</code> expires
before <code>addend</code>, then <code>self</code> is zero-extended and the carry propagates
through the rest of <code>addend</code>, growing <code>self</code> until <code>addend</code> expires.</p>
<p>An infinite <code>addend</code> will cause unbounded memory growth until the vector
overflows and panics.</p>
<h5 id="parameters-10"><a href="#parameters-10">Parameters</a></h5>
<ul>
<li><code>self</code></li>
<li><code>addend: impl IntoIterator&lt;Item=bool&gt;</code>: A stream of bits to add into
<code>self</code>, from left to right.</li>
</ul>
<h5 id="returns-9"><a href="#returns-9">Returns</a></h5>
<p>The sum vector of <code>self</code> and <code>addend</code>.</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">add_reverse</span>(<span class="ident">b</span>);
<span class="macro">assert_eq!</span>(<span class="ident">c</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_assign_reverse" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#675-693">source</a></span><a href="#method.add_assign_reverse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_assign_reverse" class="fnname">add_assign_reverse</a>&lt;I&gt;(&amp;mut self, addend: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Performs “reverse” addition (left to right instead of right to left).</p>
<p>This addition traverses the addends from left to right, performing
the addition at each index and writing the sum into <code>self</code>.</p>
<p>If <code>addend</code> expires before <code>self</code> does, <code>addend</code> is zero-extended and
the carry propagates through the rest of <code>self</code>. If <code>self</code> expires
before <code>addend</code>, then <code>self</code> is zero-extended and the carry propagates
through the rest of <code>addend</code>, growing <code>self</code> until <code>addend</code> expires.</p>
<p>An infinite <code>addend</code> will cause unbounded memory growth until the vector
overflows and panics.</p>
<h5 id="parameters-11"><a href="#parameters-11">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>addend: impl IntoIterator&lt;Item=bool&gt;</code>: A stream of bits to add into
<code>self</code>, from left to right.</li>
</ul>
<h5 id="effects"><a href="#effects">Effects</a></h5>
<p><code>self</code> may grow as a result of the final carry-out bit being <code>1</code> and
pushed onto the right end.</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span>     <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">a</span>.<span class="ident">add_assign_reverse</span>(<span class="ident">b</span>.<span class="ident">iter</span>().<span class="ident">copied</span>());
<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.change_order" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#709-714">source</a></span><a href="#method.change_order" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.change_order" class="fnname">change_order</a>&lt;P&gt;(self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;P, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Changes the order type on the vector handle, without changing its
contents.</p>
<h5 id="parameters-12"><a href="#parameters-12">Parameters</a></h5>
<ul>
<li><code>self</code></li>
</ul>
<h5 id="returns-10"><a href="#returns-10">Returns</a></h5>
<p>An equivalent vector handle with a new order type. The contents of the
backing storage are unchanged.</p>
<p>To reorder the bits in memory, drain this vector into a new handle with
the desired order type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_boxed_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#725-735">source</a></span><a href="#method.into_boxed_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_boxed_bitslice" class="fnname">into_boxed_bitslice</a>(self) -&gt; <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Degrades a <code>BitVec</code> to a <code>BitBox</code>, freezing its size.</p>
<h5 id="parameters-13"><a href="#parameters-13">Parameters</a></h5>
<ul>
<li><code>self</code></li>
</ul>
<h5 id="returns-11"><a href="#returns-11">Returns</a></h5>
<p>Itself, with its size frozen and ungrowable.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_vec" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#746-753">source</a></span><a href="#method.into_vec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_vec" class="fnname">into_vec</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Degrades a <code>BitVec</code> to a standard <code>Vec</code>.</p>
<h5 id="parameters-14"><a href="#parameters-14">Parameters</a></h5>
<ul>
<li><code>self</code></li>
</ul>
<h5 id="returns-12"><a href="#returns-12">Returns</a></h5>
<p>The plain vector underlying the <code>BitVec</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.force_align" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec.rs.html#784-799">source</a></span><a href="#method.force_align" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.force_align" class="fnname">force_align</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Ensures that the live region of the underlying memory begins at the <code>0</code>
bit position.</p>
<h5 id="notes-2"><a href="#notes-2">Notes</a></h5>
<p>This method is currently implemented as a linear traversal that moves
each bit individually from its original index to its final position.
This is <code>O(n)</code> in the bit length of the vector.</p>
<p>It is possible to create an optimized rotation behavior that only moves
a few bits individually, then moves elements in a gallop. The speed
difference is proportional to the width of the element type.</p>
<p>When this behavior is implemented, <code>force_align</code> will be rewritten to
take advantage of it. For now, it remains slow.</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="macro">bits!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>][<span class="number">1</span> .. <span class="number">7</span>];
<span class="macro">assert_eq!</span>(<span class="ident">src</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">to_owned</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0xB6</span>);
<span class="ident">bv</span>.<span class="ident">force_align</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0x6E</span>);</code></pre></div>
</div></details></div></details><h2 id="deref-methods-BitSlice%3CO%2C%20T%3E" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt;</span><a href="#deref-methods-BitSlice%3CO%2C%20T%3E" class="anchor"></a></h2><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#273-275">source</a></span><a href="#method.len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of bits in the slice.</p>
<h5 id="original"><a href="#original">Original</a></h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Local</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#292-294">source</a></span><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the slice has a length of 0.</p>
<h5 id="original-1"><a href="#original-1">Original</a></h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Local</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">is_empty</span>());

<span class="macro">assert!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::empty</span>().<span class="ident">is_empty</span>())</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#312-314">source</a></span><a href="#method.first" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first bit of the slice, or <code>None</code> if it is empty.</p>
<h5 id="original-2"><a href="#original-2">Original</a></h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">1u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">first</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::empty</span>().<span class="ident">first</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#335-337">source</a></span><a href="#method.first_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the first bit of the slice, or <code>None</code> if it
is empty.</p>
<h5 id="original-3"><a href="#original-3">Original</a></h5>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">first</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">first_mut</span>() {
    <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">1u8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#353-361">source</a></span><a href="#method.split_first" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a>&amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">1u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first</span>() {
    <span class="macro">assert_eq!</span>(<span class="ident">first</span>, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> ..]);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#380-388">source</a></span><a href="#method.split_first_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the first and all the rest of the bits of the slice, or <code>None</code>
if it is empty.</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first_mut</span>() {
    <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">at</span>(<span class="number">1</span>) <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">7</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#404-412">source</a></span><a href="#method.split_last" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a>&amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or <code>None</code> if
it is empty.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">1u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last</span>() {
    <span class="macro">assert_eq!</span>(<span class="ident">last</span>, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="kw-2">&amp;</span><span class="ident">bits</span>[.. <span class="number">7</span>]);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#431-439">source</a></span><a href="#method.split_last_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last and all the rest of the bits of the slice, or <code>None</code> if
it is empty.</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last_mut</span>() {
    <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">at</span>(<span class="number">1</span>) <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">128</span> <span class="op">|</span> <span class="number">64</span> <span class="op">|</span> <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#452-457">source</a></span><a href="#method.last" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the last bit of the slice, or <code>None</code> if it is empty.</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">1u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">bits</span>.<span class="ident">last</span>());
<span class="macro">assert!</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::empty</span>().<span class="ident">last</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#472-477">source</a></span><a href="#method.last_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'_, O, T&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable pointer to the last bit in the slice.</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">last</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">last_mut</span>() {
    <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">7</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#499-502">source</a></span><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a reference to a bit or subslice depending on the type of
<code>index</code>.</p>
<ul>
<li>If given a position, returns a reference to the bit at that position
or <code>None</code> if out of bounds.</li>
<li>If given a range, returns the subslice corresponding to that range, or
<code>None</code> if out of bounds.</li>
</ul>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>), <span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">0</span>));
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">8</span>).<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">1</span> ..).<span class="ident">expect</span>(<span class="string">&quot;in bounds&quot;</span>).<span class="ident">not_any</span>());
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(.. <span class="number">12</span>).<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#524-527">source</a></span><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a mutable reference to a bit or subslice depending on the type
of <code>index</code> (see <a href="#method.get"><code>get</code></a>) or <code>None</code> if the index is out of bounds.</p>
<h5 id="examples-46"><a href="#examples-46">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">bit</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get_mut</span>(<span class="number">1</span>) {
    <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">bits</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get_mut</span>(<span class="number">5</span> .. <span class="number">7</span>) {
    <span class="ident">bits</span>.<span class="ident">set_all</span>(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">64</span> <span class="op">|</span> <span class="number">32</span> <span class="op">|</span> <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#555-558">source</a></span><a href="#method.get_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a reference to a bit or subslice, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.get"><code>get</code></a>.</p>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>As this function does not perform boundary checking, the caller must
ensure that <code>self</code> is an index within the boundaries of <code>slice</code> before
calling in order to avoid boundary escapes and ensuing safety
violations.</p>
<h5 id="examples-47"><a href="#examples-47">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">4u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">unsafe</span> {
    <span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get_unchecked</span>(<span class="number">2</span>));
    <span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>));
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#591-594">source</a></span><a href="#method.get_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns a mutable reference to a bit or subslice, without doing bounds
checking.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.get_mut"><code>get_mut</code></a>.</p>
<h5 id="safety-4"><a href="#safety-4">Safety</a></h5>
<p>As this function does not perform boundary checking, the caller must
ensure that <code>self</code> is an index within the boundaries of <code>slice</code> before
calling in order to avoid boundary escapes and ensuing safety
violations.</p>
<h5 id="examples-48"><a href="#examples-48">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">0</span>);
    <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="ident">drop</span>(<span class="ident">bit</span>); <span class="comment">// release the borrow immediately</span>
    <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">6</span> ..);
    <span class="ident">bits</span>.<span class="ident">set_all</span>(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">1</span> <span class="op">|</span> <span class="number">2</span> <span class="op">|</span> <span class="number">128</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#629-631">source</a></span><a href="#method.as_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Returns a raw pointer to the slice’s buffer.</p>
<p>The caller must ensure that the slice outlives the pointer this function
returns, or else it will end up pointing to garbage.</p>
<p>The caller must also ensure that the memory the pointer
(non-transitively) points to is never written to (except inside an
<code>UnsafeCell</code>) using this pointer or any pointer derived from it. If you
need to mutate the contents of the buffer, use <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<p>Modifying the container referenced by this slice may cause its buffer to
be reallocated, which would also make any pointers to it invalid.</p>
<h5 id="notes-3"><a href="#notes-3">Notes</a></h5>
<p>This pointer is always to the first <code>T</code> element in the backing storage,
even if that element is only partially used by the <code>self</code> slice.
Multiple separate <code>BitSlice</code> handles may produce the same pointer with
this method.</p>
<h5 id="examples-49"><a href="#examples-49">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">2</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="ident">head</span>.<span class="ident">as_ptr</span>(), <span class="ident">rest</span>.<span class="ident">as_ptr</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#660-662">source</a></span><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Returns an unsafe mutable pointer to the slice’s buffer.</p>
<p>The caller must ensure thath the slice outlives the pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>Modifying the container referenced by this slice may couse its buffer to
be reallocated, which would also make any pointers to it invalid.</p>
<h5 id="notes-4"><a href="#notes-4">Notes</a></h5>
<p>This pointer is always to the first <code>T</code> element in the backing storage,
even if that element is only partially used by the <code>self</code> slice.
Multiple separate <code>BitSlice</code> handles may produce the same pointer with
this method.</p>
<h5 id="examples-50"><a href="#examples-50">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">2</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
<span class="macro">assert_eq!</span>(<span class="ident">head</span>.<span class="ident">as_mut_ptr</span>(), <span class="ident">rest</span>.<span class="ident">as_mut_ptr</span>());
<span class="kw">unsafe</span> { <span class="kw-2">*</span><span class="ident">head</span>.<span class="ident">as_mut_ptr</span>() <span class="op">=</span> <span class="number">2</span>; }
<span class="macro">assert!</span>(<span class="ident">rest</span>[<span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#684-689">source</a></span><a href="#method.swap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in the slice.</p>
<h5 id="arguments"><a href="#arguments">Arguments</a></h5>
<ul>
<li><code>a</code>: The index of the first bit</li>
<li><code>b</code>: The index of the second bit</li>
</ul>
<h5 id="panics-11"><a href="#panics-11">Panics</a></h5>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>
<h5 id="examples-51"><a href="#examples-51">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">2u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">swap</span>(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reverse" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#702-720">source</a></span><a href="#method.reverse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverses the order of bits in the slice, in place.</p>
<h5 id="examples-52"><a href="#examples-52">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b1_1001100u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">1</span> ..].<span class="ident">reverse</span>();
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b1_0011001</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#738-740">source</a></span><a href="#method.iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over the slice.</p>
<h5 id="examples-53"><a href="#examples-53">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">iter</span>();
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">false</span>));
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#756-758">source</a></span><a href="#method.iter_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../slice/struct.BitMut.html" title="struct bitvec::slice::BitMut">BitMut</a>&lt;'a, O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator that allows modifying each bit.</p>
<h5 id="examples-54"><a href="#examples-54">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">2</span>];
<span class="kw">for</span> <span class="kw-2">mut</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">iter_mut</span>() {
    <span class="kw-2">*</span><span class="ident">bit</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.windows" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#790-796">source</a></span><a href="#method.windows" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, width: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all contiguous windows of width <code>width</code>.</p>
<p>The windows overlap. If the slice is shorter than <code>width</code>, the iterator
returns no values.</p>
<h5 id="panics-12"><a href="#panics-12">Panics</a></h5>
<p>Panics if <code>width</code> is 0.</p>
<h5 id="examples-55"><a href="#examples-55">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b100_010_01u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>[.. <span class="number">5</span>].<span class="ident">windows</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If the slice is shorter than <code>width</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Local</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>[.. <span class="number">3</span>].<span class="ident">windows</span>(<span class="number">4</span>);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#828-834">source</a></span><a href="#method.chunks" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact"><code>chunks_exact</code></a> for a variant of this iterator that returns chunks
of always exactly <code>chunk_size</code> elements, and <a href="#method.rchunks"><code>rchunks</code></a> for the same
iterator but starting at the end of the slice.</p>
<h5 id="panics-13"><a href="#panics-13">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-56"><a href="#examples-56">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_010_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> .. <span class="number">8</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#869-875">source</a></span><a href="#method.chunks_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length <code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for the
same iterator but starting at the end of the slice.</p>
<h5 id="panics-14"><a href="#panics-14">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-57"><a href="#examples-57">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">chunks_mut</span>(<span class="number">3</span>) {
    <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="number">4u8</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">count</span>);
    <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">count</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b100_010_01</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#911-922">source</a></span><a href="#method.chunks_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size - 1</code>
elements will be omitted and can be retrieved from the <code>remainder</code>
function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can
often optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.chunks"><code>chunks</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for the same
iterator but starting at the end of the slice.</p>
<h5 id="panics-15"><a href="#panics-15">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-58"><a href="#examples-58">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b100_010_01u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> .. <span class="number">8</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#964-975">source</a></span><a href="#method.chunks_exact_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time,
starting at the beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size - 1</code>
elements will be omitted and can be retrieved from the <code>into_remainder</code>
function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can
often optimize the resulting code better than in the case of
<a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.chunks_mut"><code>chunks_mut</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for the same
iterator but starting at the end of the slice of the slice.</p>
<h5 id="panics-16"><a href="#panics-16">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-59"><a href="#examples-59">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0u8</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact_mut</span>(<span class="number">3</span>);
<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="kw-2">&amp;mut</span> <span class="ident">iter</span> {
    <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="number">4u8</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">count</span>);
    <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}
<span class="ident">iter</span>.<span class="ident">into_remainder</span>().<span class="ident">store</span>(<span class="number">1u8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">count</span>, <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b100_010_01</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1007-1013">source</a></span><a href="#method.rchunks" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last chunk will not have length
of the slice, then the last chunk will not have length <code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for a variant of this iterator that returns chunks
of always exactly <code>chunk_size</code> bits, and <a href="#method.chunks"><code>chunks</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h5 id="panics-17"><a href="#panics-17">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-60"><a href="#examples-60">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b01_010_100u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> .. <span class="number">8</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">2</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1049-1055">source</a></span><a href="#method.rchunks_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not have
length of the slice, then the last chunk will not have length
<code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for a variant of this iterator that returns
chunks of always exactly <code>chunk_size</code> bits, and <a href="#method.chunks_mut"><code>chunks_mut</code></a> for the
same iterator but starting at the beginning of the slice.</p>
<h5 id="panics-18"><a href="#panics-18">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-61"><a href="#examples-61">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rchunks_mut</span>(<span class="number">3</span>) {
    <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="number">4u8</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">count</span>);
    <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">count</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b100_010_01</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1092-1100">source</a></span><a href="#method.rchunks_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not
divide the length of the slice, then the last up to <code>chunk_size - 1</code>
bits will be omitted and can be retrieved from the <code>remainder</code> function
of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler can
often optimize the resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.rchunks"><code>rchunks</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.chunks_exact"><code>chunks_exact</code></a> for the same iterator
but starting at the beginning of the slice.</p>
<h5 id="panics-19"><a href="#panics-19">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-62"><a href="#examples-62">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b100_010_01u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> .. <span class="number">8</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">5</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> ..<span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1143-1151">source</a></span><a href="#method.rchunks_exact_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, O, T&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> bits of the slice at a time,
starting at the end of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last up to <code>chunk_size - 1</code>
bits will be omitted and can be retrieved from the <code>into_remainder</code>
function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> bits, the compiler can
often optimize the resulting code better than in the case of
<a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for a variant of this iterator that also returns the
remainder as a smaller chunk, and <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for the same
iterator but starting at the beginning of the slice.</p>
<h5 id="panics-20"><a href="#panics-20">Panics</a></h5>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h5 id="examples-63"><a href="#examples-63">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact_mut</span>(<span class="number">3</span>);

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="kw-2">&amp;mut</span> <span class="ident">iter</span> {
    <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="number">4u8</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">count</span>);
    <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}
<span class="ident">iter</span>.<span class="ident">into_remainder</span>().<span class="ident">store</span>(<span class="number">1u8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b100_010_01</span>);
<span class="macro">assert_eq!</span>(<span class="ident">count</span>, <span class="number">2</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1188-1192">source</a></span><a href="#method.split_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a></h4></section></summary><div class="docblock"><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h5 id="panics-21"><a href="#panics-21">Panics</a></h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="examples-64"><a href="#examples-64">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0x0Fu8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">0</span>);
    <span class="macro">assert!</span>(<span class="ident">left</span>.<span class="ident">is_empty</span>());
    <span class="macro">assert_eq!</span>(<span class="ident">right</span>, <span class="ident">bits</span>);
}

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">4</span>);
    <span class="macro">assert!</span>(<span class="ident">left</span>.<span class="ident">not_any</span>());
    <span class="macro">assert!</span>(<span class="ident">right</span>.<span class="ident">all</span>());
}

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">8</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">left</span>, <span class="ident">bits</span>);
    <span class="macro">assert!</span>(<span class="ident">right</span>.<span class="ident">is_empty</span>());
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1220-1223">source</a></span><a href="#method.split_at_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a></h4></section></summary><div class="docblock"><p>Divides one mutable slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding the index
<code>mid</code> itself) and the second will contain all indices from <code>[mid, len)</code>
(excluding the index <code>len</code> itself).</p>
<h5 id="panics-22"><a href="#panics-22">Panics</a></h5>
<p>Panics if <code>mid &gt; len</code>.</p>
<h5 id="examples-65"><a href="#examples-65">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0x0Fu8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
<span class="macro">assert!</span>(<span class="ident">left</span>.<span class="ident">not_any</span>());
<span class="macro">assert!</span>(<span class="ident">right</span>.<span class="ident">all</span>());
<span class="kw-2">*</span><span class="ident">left</span>.<span class="ident">at</span>(<span class="number">1</span>) <span class="op">=</span> <span class="bool-val">true</span>;
<span class="kw-2">*</span><span class="ident">right</span>.<span class="ident">at</span>(<span class="number">2</span>) <span class="op">=</span> <span class="bool-val">false</span>;

<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b0100_1101</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1284-1291">source</a></span><a href="#method.split" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, func: F) -&gt; <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by indexed bits that
satisfy the predicate <code>func</code>tion. The matched position is not contained
in the subslices.</p>
<h5 id="api-differences-1"><a href="#api-differences-1">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split"><code>slice::split</code></a> method takes a predicate function with signature
<code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has signature
<code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because <code>BitSlice</code> by
definition has only one bit of information per slice item, and including
the index allows the callback function to make more informed choices.</p>
<h5 id="examples-66"><a href="#examples-66">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b01_001_000u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">5</span> .. <span class="number">8</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If the first position is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last position in the slice
is matched, an empty slice will be the last item returned by the
iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">1u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::empty</span>());
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If two matched positions are directly adjacent, an empty slice will be
present between them.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_100_00u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">Local</span>, <span class="ident">usize</span><span class="op">&gt;</span><span class="ident">::empty</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">8</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1321-1328">source</a></span><a href="#method.split_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, func: F) -&gt; <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by indexed bits
that satisfy the predicate <code>func</code>tion. The matched position is not
contained in the subslices.</p>
<h5 id="api-differences-2"><a href="#api-differences-2">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-67"><a href="#examples-67">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b001_000_10u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">split_mut</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
    <span class="kw-2">*</span><span class="ident">group</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b101_1001_1u8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1374-1379">source</a></span><a href="#method.rsplit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, func: F) -&gt; <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by indexed bits that
satisfy a predicate <code>func</code>tion, starting at the end of the slice and
working backwards. The matched position is not contained in the
subslices.</p>
<h5 id="api-differences-3"><a href="#api-differences-3">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-68"><a href="#examples-68">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0001_0000u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">8</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>As with <code>split()</code>, if the first or last position is matched, an empty
slice will be the first (or last) item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b1001_0001u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">4</span> .. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">3</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1412-1417">source</a></span><a href="#method.rsplit_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, func: F) -&gt; <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by indexed bits
that satisfy a predicate <code>func</code>tion, starting at the end of the slice
and working backwards. The matched position is not contained in the
subslices.</p>
<h5 id="api-differences-4"><a href="#api-differences-4">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-69"><a href="#examples-69">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplit_mut</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>) {
    <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
    <span class="ident">group</span>.<span class="ident">store</span>(<span class="ident">count</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b11_0_10_0_01</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1453-1461">source</a></span><a href="#method.splitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, func: F) -&gt; <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by indexed bits that
satisfy the predicate <code>func</code>tion, limited to returning at most <code>n</code>
items. The matched position is not contained in the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h5 id="api-differences-5"><a href="#api-differences-5">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-70"><a href="#examples-70">Examples</a></h5>
<p>Print the slice split once by indices divisible by 3:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">group</span>);
}
<span class="comment">//  [10]</span>
<span class="comment">//  [00101]</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1496-1504">source</a></span><a href="#method.splitn_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, func: F) -&gt; <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by indexed bits
that satisfy the predicate <code>func</code>tion, limited to returning at most <code>n</code>
items. The matched position is not contained in the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h5 id="api-differences-6"><a href="#api-differences-6">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-71"><a href="#examples-71">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">counter</span> <span class="op">=</span> <span class="number">0u8</span>;

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">splitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">4</span> <span class="op">==</span> <span class="number">3</span>) {
    <span class="ident">counter</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
    <span class="ident">group</span>.<span class="ident">store</span>(<span class="ident">counter</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b001_0_0010</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1542-1550">source</a></span><a href="#method.rsplitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, func: F) -&gt; <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over subslices separated by indexed bits that
satisfy a predicate <code>func</code>tion, limited to returning at most <code>n</code> items.
This starts at the end of the slice and works backwards. The matched
position is not contained in the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h5 id="api-differences-7"><a href="#api-differences-7">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-72"><a href="#examples-72">Examples</a></h5>
<p>Print the slice split once, starting from the end, by indices divisible
by 3:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xA5u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">group</span>);
}
<span class="comment">//  [01]</span>
<span class="comment">//  [10100]</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1586-1594">source</a></span><a href="#method.rsplitn_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, func: F) -&gt; <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, O, T, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, F&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, O, T, F&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, O, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns an iterator over mutable subslices separated by indexed bits
that satisfy a predicate <code>func</code>tion, limited to returning at most <code>n</code>
items. This starts at the end of the slice and works backwards. The
matched position is not contained in the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h5 id="api-differences-8"><a href="#api-differences-8">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a> method takes a predicate function with
signature <code>(&amp;T) -&gt; bool</code>, whereas this method’s predicate function has
signature <code>(usize, &amp;T) -&gt; bool</code>. This difference is in place because
<code>BitSlice</code> by definition has only one bit of information per slice item,
and including the index allows the callback function to make more
informed choices.</p>
<h5 id="examples-73"><a href="#examples-73">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">counter</span> <span class="op">=</span> <span class="number">0u8</span>;

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>) {
    <span class="ident">counter</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
    <span class="ident">group</span>.<span class="ident">store</span>(<span class="ident">counter</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b00010_0_01</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1620-1627">source</a></span><a href="#method.contains" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.contains" class="fnname">contains</a>&lt;P, U&gt;(&amp;self, query: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;P, U&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the slice contains a region that matches the given
span.</p>
<h5 id="api-differences-9"><a href="#api-differences-9">API Differences</a></h5>
<p>The <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.contains"><code>slice::contains</code></a> method tests for a single slice element.
Because this is a slice of single bits, testing for the presence of one
<code>bool</code> value is not very informative. This instead searches for a
subslice, which may be one or more bits.</p>
<h5 id="examples-74"><a href="#examples-74">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0101_1010u8</span>;
<span class="kw">let</span> <span class="ident">bits_be</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_le</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="ident">bits_be</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">bits_le</span>[<span class="number">1</span> .. <span class="number">5</span>]));</code></pre></div>
<p>This example uses a palindrome pattern to demonstrate that the query
does not need to have the same type parameters as the searched slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.starts_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1639-1643">source</a></span><a href="#method.starts_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;P, U&gt;(&amp;self, prefix: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;P, U&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>prefix</code> is a prefix of the slice.</p>
<h5 id="examples-75"><a href="#examples-75">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0110_1110u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">2</span>]));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ends_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1655-1660">source</a></span><a href="#method.ends_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;P, U&gt;(&amp;self, suffix: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;P, U&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>suffix</code> is a suffix of the slice.</p>
<h5 id="examples-76"><a href="#examples-76">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0111_1010u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[<span class="number">6</span> ..]));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_left" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1696-1733">source</a></span><a href="#method.rotate_left" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the slice in-place such that the first <code>by</code> bits of the slice
move to the end while the last <code>self.len() - by</code> bits move to the
front. After calling <code>rotate_left</code>, the bit previously at index <code>by</code>
will become the first bit in the slice.</p>
<h5 id="panics-23"><a href="#panics-23">Panics</a></h5>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a noöp
rotation.</p>
<h5 id="complexity"><a href="#complexity">Complexity</a></h5>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h5 id="examples-77"><a href="#examples-77">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">rotate_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0xC3</span>);</code></pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">5</span>].<span class="ident">rotate_left</span>(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b1_1101_000</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_right" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1769-1806">source</a></span><a href="#method.rotate_right" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the slice in-place such that the first <code>self.len() - by</code> bits of
the slice move to the end while the last <code>by</code> bits move to the front.
After calling <code>rotate_right</code>, the bit previously at index
<code>self.len() - by</code> will become the first bit in the slice.</p>
<h5 id="panics-24"><a href="#panics-24">Panics</a></h5>
<p>This function will panic if <code>by</code> is greater than the length of the
slice. Note that <code>by == self.len()</code> does <em>not</em> panic and is a noöp
rotation.</p>
<h5 id="complexity-1"><a href="#complexity-1">Complexity</a></h5>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h5 id="examples-78"><a href="#examples-78">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">rotate_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0x3C</span>);</code></pre></div>
<p>Rotate a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0xF0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">1</span> .. <span class="number">5</span>].<span class="ident">rotate_right</span>(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b1_0111_000</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1853-1865">source</a></span><a href="#method.clone_from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.clone_from_slice" class="fnname">clone_from_slice</a>&lt;P, U&gt;(&amp;mut self, src: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;P, U&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Copies the elements from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>This is equivalent to <code>copy_from_slice</code>; this function is only included
for API surface equivalence.</p>
<h5 id="panics-25"><a href="#panics-25">Panics</a></h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-79"><a href="#examples-79">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0x0Fu16</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">clone_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[.. <span class="number">8</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0xF0</span>);</code></pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use <code>clone_from_slice</code> on a single
slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">clone_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> ..]);</code></pre></div>
<p>To work around this, we can use [<code>split_at_mut</code>] to create two distinct
sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
<span class="ident">head</span>.<span class="ident">clone_from_slice</span>(<span class="ident">tail</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0x33</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_from_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1913-1915">source</a></span><a href="#method.copy_from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.copy_from_slice" class="fnname">copy_from_slice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Copies the elements from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>This is restricted to take exactly the same type of bit slice as the
source slice, so that the implementation has the chace to use faster
<code>memcpy</code> if possible.</p>
<h5 id="panics-26"><a href="#panics-26">Panics</a></h5>
<p>This function will panic if the two slices have different lengths.</p>
<h5 id="examples-80"><a href="#examples-80">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0x0Fu8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>.<span class="ident">copy_from_slice</span>(<span class="ident">src</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0x0F</span>);</code></pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use <code>copy_from_slice</code> on a single
slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">copy_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">6</span> ..]);</code></pre></div>
<p>To work around this, we can use [<code>split_at_mut</code>] to create two distinct
sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">3u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
<span class="ident">head</span>.<span class="ident">copy_from_slice</span>(<span class="ident">tail</span>);
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0x33</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_with_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1969-1981">source</a></span><a href="#method.swap_with_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap_with_slice" class="fnname">swap_with_slice</a>&lt;P, U&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;P, U&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Swaps all bits in <code>self</code> with those in <code>other</code>.</p>
<p>The length of <code>other</code> must be the same as <code>self</code>.</p>
<h5 id="panics-27"><a href="#panics-27">Panics</a></h5>
<p>This function will panic if the two slices hav different lengths.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Swapping two elements across slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="number">0x96A5u16</span>;
<span class="kw">let</span> <span class="ident">bits_a</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bits_b</span> <span class="op">=</span> <span class="ident">b</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="ident">bits_a</span>.<span class="ident">swap_with_slice</span>(<span class="kw-2">&amp;mut</span> <span class="ident">bits_b</span>[<span class="number">4</span> .. <span class="number">12</span>]);

<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="number">0x56</span>);
<span class="macro">assert_eq!</span>(<span class="ident">b</span>, <span class="number">0x9005</span>);</code></pre></div>
<p>Rust enforces that there can only be one mutable reference to a
particular piece of data in a particular scope. Because of this,
attempting to use <code>swap_with_slice</code> on a single slice will result in a
compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">15u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[.. <span class="number">3</span>].<span class="ident">swap_with_slice</span>(<span class="kw-2">&amp;mut</span> <span class="ident">bits</span>[<span class="number">5</span> ..]);</code></pre></div>
<p>To work around this, we can use [<code>split_at_mut</code>] to create two distinct
mutable sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">15u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
    <span class="ident">left</span>[.. <span class="number">2</span>].<span class="ident">swap_with_slice</span>(<span class="kw-2">&amp;mut</span> <span class="ident">right</span>[<span class="number">2</span> ..]);
}

<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0xCC</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2021-2030">source</a></span><a href="#method.align_to" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self, &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Transmute the slice to a slice with a different backing store, ensuring
alignment of the types is maintained.</p>
<p>This method splits the slice into three distinct slices: prefix,
correctly aligned middle slice of a new backing type, and the suffix
slice. The method does a best effort to make the middle slice the
greatest length possible for a given type and input slice, but only your
algorithm’s performance should depend on that, not its correctness.</p>
<h5 id="safety-5"><a href="#safety-5">Safety</a></h5>
<p>This method is essentially a <code>transmute</code> with respect to the elements in
the returned middle slice, so all the usual caveats pertaining to
<code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h5 id="examples-81"><a href="#examples-81">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
    <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Local</span><span class="op">&gt;</span>();
    <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">align_to</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
    <span class="kw">match</span> <span class="ident">prefix</span>.<span class="ident">len</span>() {
        <span class="number">0</span> =&gt; {
            <span class="macro">assert_eq!</span>(<span class="ident">shorts</span>, <span class="ident">bits</span>[.. <span class="number">48</span>]);
            <span class="macro">assert_eq!</span>(<span class="ident">suffix</span>, <span class="ident">bits</span>[<span class="number">48</span> ..]);
        },
        <span class="number">8</span> =&gt; {
            <span class="macro">assert_eq!</span>(<span class="ident">prefix</span>, <span class="ident">bits</span>[.. <span class="number">8</span>]);
            <span class="macro">assert_eq!</span>(<span class="ident">shorts</span>, <span class="ident">bits</span>[<span class="number">8</span> ..]);
        },
        <span class="kw">_</span> =&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;This case will not occur&quot;</span>)
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2061-2073">source</a></span><a href="#method.align_to_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, U&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Transmute the slice to a slice with a different backing store, ensuring
alignment of the types is maintained.</p>
<p>This method splits the slice into three distinct slices: prefix,
correctly aligned middle slice of a new backing type, and the suffix
slice. The method does a best effort to make the middle slice the
greatest length possible for a given type and input slice, but only your
algorithm’s performance should depend on that, not its correctness.</p>
<h5 id="safety-6"><a href="#safety-6">Safety</a></h5>
<p>This method is essentially a <code>transmute</code> with respect to the elements in
the returned middle slice, so all the usual caveats pertaining to
<code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h5 id="examples-82"><a href="#examples-82">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
    <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Local</span><span class="op">&gt;</span>();
    <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">align_to_mut</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
    <span class="comment">//  same access and behavior as in `align_to`</span>
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_vec" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2088-2090">source</a></span><a href="#method.to_vec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_vec" class="fnname">to_vec</a>(&amp;self) -&gt; <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Copies <code>self</code> into a new <code>BitVec</code>.</p>
<h5 id="examples-83"><a href="#examples-83">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">0u8</span>, <span class="op">!</span><span class="number">0u8</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Local</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">to_vec</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="ident">vec</span>);</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#310-314">source</a></span><a href="#method.set" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set" class="fnname">set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets the bit value at the given position.</p>
<h5 id="parameters-15"><a href="#parameters-15">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to set. It must be in the domain
<code>0 .. self.len()</code>.</li>
<li><code>value</code>: The value to be set, <code>true</code> for <code>1</code> and <code>false</code> for <code>0</code>.</li>
</ul>
<h5 id="panics-28"><a href="#panics-28">Panics</a></h5>
<p>This method panics if <code>index</code> is outside the slice domain.</p>
<h5 id="examples-84"><a href="#examples-84">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">store</span> <span class="op">=</span> <span class="number">8u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">store</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">3</span>]);
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">3</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">3</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#360-365">source</a></span><a href="#method.set_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.set_unchecked" class="fnname">set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets a bit at an index, without doing bounds checking.</p>
<p>This is generally not recommended; use with caution! For a safe
alternative, see <a href="#method.set"><code>set</code></a>.</p>
<h5 id="parameters-16"><a href="#parameters-16">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit index to retrieve. This index is <em>not</em> checked
against the length of <code>self</code>.</li>
</ul>
<h5 id="effects-1"><a href="#effects-1">Effects</a></h5>
<p>The bit at <code>index</code> is set to <code>value</code>.</p>
<h5 id="safety-7"><a href="#safety-7">Safety</a></h5>
<p>This method is <strong>not</strong> safe. It performs raw pointer arithmetic to seek
from the start of the slice to the requested index, and set the bit
there. It does not inspect the length of <code>self</code>, and it is free to
perform out-of-bounds memory <em>write</em> access.</p>
<p>Use this method <strong>only</strong> when you have already performed the bounds
check, and can guarantee that the call occurs with a safely in-bounds
index.</p>
<h5 id="examples-85"><a href="#examples-85">Examples</a></h5>
<p>This example uses a bit slice of length 2, and demonstrates
out-of-bounds access to the last bit in the element.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">src</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">2</span> .. <span class="number">4</span>];
 <span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">2</span>);
 <span class="kw">unsafe</span> { <span class="ident">bits</span>.<span class="ident">set_unchecked</span>(<span class="number">5</span>, <span class="bool-val">true</span>); }
}
<span class="macro">assert_eq!</span>(<span class="ident">src</span>, <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#442-445">source</a></span><a href="#method.at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.at" class="fnname">at</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></h4></section><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 0.18.0: <p>Use <code>.get_mut()</code> instead</p>
</div></div></summary><div class="docblock"><p>Produces a write reference to a region of the slice.</p>
<p>This method corresponds to [<code>Index::index</code>], except that it produces a
writable reference rather than a read-only reference. See
<a href="trait.BitSliceIndex.html"><code>BitSliceIndex</code></a> for the possible types of the produced reference.</p>
<p>Use of this method locks the <code>&amp;mut BitSlice</code> for the duration of the
produced reference’s lifetime. If you need multiple <strong>non-overlapping</strong>
write references into a single source <code>&amp;mut BitSlice</code>, see the
<a href="#method.split_at_mut"><code>::split_at_mut</code></a> method.</p>
<h5 id="lifetimes"><a href="#lifetimes">Lifetimes</a></h5>
<ul>
<li><code>'a</code>: Propagates the lifetime of the referent slice to the interior
reference produced.</li>
</ul>
<h5 id="parameters-17"><a href="#parameters-17">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: Some value whose type can be used to index <code>BitSlice</code>s.</li>
</ul>
<h5 id="returns-13"><a href="#returns-13">Returns</a></h5>
<p>A writable reference into <code>self</code>, whose exact type is determined by
<code>index</code>’s implementation of <a href="trait.BitSliceIndex.html"><code>BitSliceIndex</code></a>. This may be either a
smaller <code>&amp;mut BitSlice</code> when <code>index</code> is a range, or a <a href="../slice/struct.BitMut.html" title="BitMut"><code>BitMut</code></a> proxy
type when <code>index</code> is a <code>usize</code>. See the <a href="../slice/struct.BitMut.html" title="BitMut"><code>BitMut</code></a> documentation for
information on how to use it.</p>
<h5 id="panics-29"><a href="#panics-29">Panics</a></h5>
<p>This panics if <code>index</code> is out of bounds of <code>self</code>.</p>
<h5 id="examples-86"><a href="#examples-86">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span>]);
<span class="kw-2">*</span><span class="ident">bits</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
<span class="comment">//  note the leading dereference.</span>
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);</code></pre></div>
<p>This example shows multiple usage by using <code>split_at_mut</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

{
 <span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">a</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
 <span class="kw">let</span> (<span class="kw-2">mut</span> <span class="ident">b</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">rest</span>.<span class="ident">split_at_mut</span>(<span class="number">3</span>);
 <span class="kw-2">*</span><span class="ident">a</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
 <span class="kw-2">*</span><span class="ident">b</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
 <span class="kw-2">*</span><span class="ident">rest</span>.<span class="ident">at</span>(<span class="number">0</span>) <span class="op">=</span> <span class="bool-val">true</span>;
}

<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0b1010_0100</span>);
<span class="comment">//                               a b   rest</span></code></pre></div>
<p>The above example splits the slice into three (the first, the second,
and the rest) in order to hold multiple write references into the slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.at_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#456-459">source</a></span><a href="#method.at_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.at_unchecked" class="fnname">at_unchecked</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, O, T&gt;,&nbsp;</span></h4></section><div class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated since 0.18.0: <p>Use <code>.get_unchecked_mut()</code> instead</p>
</div></div></summary><div class="docblock"><p>Version of <a href="#method.at"><code>at</code></a> that does not perform boundary checking.</p>
<h5 id="safety-8"><a href="#safety-8">Safety</a></h5>
<p>If <code>index</code> is outside the boundaries of <code>self</code>, then this function will
induce safety violations. The caller must ensure that <code>index</code> is within
the boundaries of <code>self</code> before calling.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#469-475">source</a></span><a href="#method.split_at_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fnname">split_at_unchecked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a></h4></section></summary><div class="docblock"><p>Version of <a href="#method.split_at"><code>split_at</code></a> that does not perform boundary
checking.</p>
<h5 id="safety-9"><a href="#safety-9">Safety</a></h5>
<p>If <code>mid</code> is outside the boundaries of <code>self</code>, then this function will
induce safety violations. The caller must ensure that <code>mid</code> is within
the boundaries of <code>self</code> before calling.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_mut_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#486-492">source</a></span><a href="#method.split_at_mut_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_mut_unchecked" class="fnname">split_at_mut_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>Self<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.tuple.html">)</a></h4></section></summary><div class="docblock"><p>Version of <a href="#method.split_at_mut"><code>split_at_mut</code></a> that does not perform
boundary checking.</p>
<h5 id="safety-10"><a href="#safety-10">Safety</a></h5>
<p>If <code>mid</code> is outside the boundaries of <code>self</code>, then this function will
induce safety violations. The caller must ensure that <code>mid</code> is within
the boundaries of <code>self</code> before calling.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#501-506">source</a></span><a href="#method.swap_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.swap_unchecked" class="fnname">swap_unchecked</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Version of <a href="#method.swap"><code>swap</code></a> that does not perform boundary checks.</p>
<h5 id="safety-11"><a href="#safety-11">Safety</a></h5>
<p><code>a</code> and <code>b</code> must be within the bounds of <code>self</code>, otherwise, the memory
access is unsound and may induce undefined behavior.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#537-564">source</a></span><a href="#method.all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.all" class="fnname">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>all</em> bits in the slice domain are set (logical <code>∧</code>).</p>
<h5 id="truth-table"><a href="#truth-table">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 1</code></pre></div><h5 id="parameters-18"><a href="#parameters-18">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-14"><a href="#returns-14">Returns</a></h5>
<p>Whether all bits in the slice domain are set. The empty slice returns
<code>true</code>.</p>
<h5 id="examples-87"><a href="#examples-87">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xFDu8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">all</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">all</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.any" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#595-622">source</a></span><a href="#method.any" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.any" class="fnname">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>any</em> bit in the slice is set (logical <code>∨</code>).</p>
<h5 id="truth-table-1"><a href="#truth-table-1">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 1</code></pre></div><h5 id="parameters-19"><a href="#parameters-19">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-15"><a href="#returns-15">Returns</a></h5>
<p>Whether any bit in the slice domain is set. The empty slice returns
<code>false</code>.</p>
<h5 id="examples-88"><a href="#examples-88">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0x40u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">any</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">any</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#653-655">source</a></span><a href="#method.not_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.not_all" class="fnname">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>any</em> bit in the slice is unset (logical <code>¬∧</code>).</p>
<h5 id="truth-table-2"><a href="#truth-table-2">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 1
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0</code></pre></div><h5 id="parameters-20"><a href="#parameters-20">Parameters</a></h5>
<ul>
<li>`&amp;self</li>
</ul>
<h5 id="returns-16"><a href="#returns-16">Returns</a></h5>
<p>Whether any bit in the slice domain is unset.</p>
<h5 id="examples-89"><a href="#examples-89">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0xFDu8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">not_all</span>());
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">not_all</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_any" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#686-688">source</a></span><a href="#method.not_any" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.not_any" class="fnname">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if <em>all</em> bits in the slice are unset (logical <code>¬∨</code>).</p>
<h5 id="truth-table-3"><a href="#truth-table-3">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 1
0 1 =&gt; 0
1 0 =&gt; 0
1 1 =&gt; 0</code></pre></div><h5 id="parameters-21"><a href="#parameters-21">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-17"><a href="#returns-17">Returns</a></h5>
<p>Whether all bits in the slice domain are unset.</p>
<h5 id="examples-90"><a href="#examples-90">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0x40u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[.. <span class="number">4</span>].<span class="ident">not_any</span>());
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">4</span> ..].<span class="ident">not_any</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.some" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#724-726">source</a></span><a href="#method.some" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.some" class="fnname">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests whether the slice has some, but not all, bits set and some, but
not all, bits unset.</p>
<p>This is <code>false</code> if either <code>all()</code> or <code>not_any()</code> are <code>true</code>.</p>
<h5 id="truth-table-4"><a href="#truth-table-4">Truth Table</a></h5><div class="example-wrap"><pre class="language-text"><code>0 0 =&gt; 0
0 1 =&gt; 1
1 0 =&gt; 1
1 1 =&gt; 0</code></pre></div><h5 id="parameters-22"><a href="#parameters-22">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-18"><a href="#returns-18">Returns</a></h5>
<p>Whether the slice domain has mixed content. The empty slice returns
<code>false</code>.</p>
<h5 id="examples-91"><a href="#examples-91">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0b111_000_10u8</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">0</span> .. <span class="number">3</span>].<span class="ident">some</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">6</span>].<span class="ident">some</span>());
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">6</span> ..].<span class="ident">some</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_ones" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#746-775">source</a></span><a href="#method.count_ones" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.count_ones" class="fnname">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts how many bits are set high.</p>
<h5 id="parameters-23"><a href="#parameters-23">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-19"><a href="#returns-19">Returns</a></h5>
<p>The number of high bits in the slice domain.</p>
<h5 id="examples-92"><a href="#examples-92">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> [<span class="number">0xFDu8</span>, <span class="number">0x25</span>].<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">count_ones</span>(), <span class="number">10</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_zeros" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#795-797">source</a></span><a href="#method.count_zeros" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fnname">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts how many bits are set low.</p>
<h5 id="parameters-24"><a href="#parameters-24">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-20"><a href="#returns-20">Returns</a></h5>
<p>The number of low bits in the slice domain.</p>
<h5 id="examples-93"><a href="#examples-93">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> [<span class="number">0xFDu8</span>, <span class="number">0x25</span>].<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">count_zeros</span>(), <span class="number">6</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#820-845">source</a></span><a href="#method.set_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_all" class="fnname">set_all</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Set all bits in the slice to a value.</p>
<h5 id="parameters-25"><a href="#parameters-25">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>value</code>: The bit value to which all bits in the slice will be set.</li>
</ul>
<h5 id="examples-94"><a href="#examples-94">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">6</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0011_1100</span>]);
<span class="ident">bits</span>[<span class="number">3</span> .. <span class="number">5</span>].<span class="ident">set_all</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b0010_0100</span>]);
<span class="ident">bits</span>[.. <span class="number">1</span>].<span class="ident">set_all</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">as_ref</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b1010_0100</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.for_each" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#873-882">source</a></span><a href="#method.for_each" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.for_each" class="fnname">for_each</a>&lt;F&gt;(&amp;mut self, func: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Provides mutable traversal of the collection.</p>
<p>It is impossible to implement <code>IndexMut</code> on <code>BitSlice</code>, because bits do
not have addresses, so there can be no <code>&amp;mut u1</code>. This method allows the
client to receive an enumerated bit, and provide a new bit to set at
each index.</p>
<h5 id="parameters-26"><a href="#parameters-26">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>func</code>: A function which receives a <code>(usize, bool)</code> pair of index and
value, and returns a bool. It receives the bit at each position, and
the return value is written back at that position.</li>
</ul>
<h5 id="examples-95"><a href="#examples-95">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> <span class="number">0u8</span>;
{
 <span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
 <span class="ident">bits</span>.<span class="ident">for_each</span>(<span class="op">|</span><span class="ident">idx</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">idx</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">src</span>, <span class="number">0b1001_0010</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_assign_reverse-1" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#942-960">source</a></span><a href="#method.add_assign_reverse-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.add_assign_reverse-1" class="fnname">add_assign_reverse</a>&lt;I&gt;(&amp;mut self, addend: I) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Performs “reverse” addition (left to right instead of right to left).</p>
<p>This addition interprets the slice, and the other addend, as having its
least significant bits first in the order and its most significant bits
last. This is most likely to be numerically useful under a
<code>Lsb0</code> <code>BitOrder</code> type.</p>
<h5 id="parameters-27"><a href="#parameters-27">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code>: The addition uses <code>self</code> as one addend, and writes the
sum back into <code>self</code>.</li>
<li><code>addend: impl IntoIterator&lt;Item=bool&gt;</code>: A stream of bits. When this is
another <code>BitSlice</code>, iteration proceeds from left to right.</li>
</ul>
<h5 id="return"><a href="#return">Return</a></h5>
<p>The final carry bit is returned</p>
<h5 id="effects-2"><a href="#effects-2">Effects</a></h5>
<p>Starting from index <code>0</code> and proceeding upwards until either <code>self</code> or
<code>addend</code> expires, the carry-propagated addition of <code>self[i]</code> and
<code>addend[i]</code> is written to <code>self[i]</code>.</p>
<div class="example-wrap"><pre class="language-text"><code>  101111
+ 0010__ (the two missing bits are logically zero)
--------
  100000 1 (the carry-out is returned)</code></pre></div><h5 id="examples-96"><a href="#examples-96">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="number">0b0000_1010u8</span>;
<span class="kw">let</span>     <span class="ident">b</span> <span class="op">=</span> <span class="number">0b0000_1100u8</span>;
<span class="comment">//      s =      1 0110</span>
<span class="kw">let</span> <span class="ident">ab</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">a</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="op">&amp;</span>    <span class="ident">b</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">ab</span>.<span class="ident">add_assign_reverse</span>(<span class="ident">bb</span>.<span class="ident">iter</span>().<span class="ident">copied</span>());
<span class="macro">assert!</span>(<span class="ident">c</span>);
<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="number">0b0000_0110u8</span>);</code></pre></div>
<h5 id="performance-notes"><a href="#performance-notes">Performance Notes</a></h5>
<p>When using <code>Lsb0</code> <code>BitOrder</code> types, this can be accelerated by
delegating the addition to the underlying types. This is a software
implementation of the <a href="https://en.wikipedia.org/wiki/Ripple-carry_adder">ripple-carry adder</a>, which has <code>O(n)</code> runtime in
the number of bits. The CPU is much faster, as it has access to
element-wise or vectorized addition operations.</p>
<p>If your use case sincerely needs binary-integer arithmetic operations on
bit sets, please file an issue.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_slice-1" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#990-999">source</a></span><a href="#method.as_slice-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_slice-1" class="fnname">as_slice</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Accesses the backing storage of the <code>BitSlice</code> as a slice of its
elements.</p>
<p>This will not include partially-owned edge elements, as they may be
contended by other slice handles.</p>
<h5 id="parameters-28"><a href="#parameters-28">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-21"><a href="#returns-21">Returns</a></h5>
<p>A slice of all the elements that the <code>BitSlice</code> uses for storage.</p>
<h5 id="examples-97"><a href="#examples-97">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">66</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">let</span> <span class="ident">accum</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_slice</span>()
  .<span class="ident">iter</span>()
  .<span class="ident">map</span>(<span class="op">|</span><span class="ident">elt</span><span class="op">|</span> <span class="ident">elt</span>.<span class="ident">count_ones</span>())
  .<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();
<span class="macro">assert_eq!</span>(<span class="ident">accum</span>, <span class="number">3</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_slice-1" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1018-1027">source</a></span><a href="#method.as_mut_slice-1" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_slice-1" class="fnname">as_mut_slice</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;mut [T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Accesses the underlying store.</p>
<p>This will not include partially-owned edge elements, as they may be
contended by other slice handles.</p>
<h5 id="examples-98"><a href="#examples-98">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">64</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">for</span> <span class="ident">elt</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">as_mut_slice</span>() {
  <span class="kw-2">*</span><span class="ident">elt</span> <span class="op">|</span><span class="op">=</span> <span class="number">2</span>;
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">66</span>], <span class="ident">bits</span>.<span class="ident">as_slice</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_total_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1043-1045">source</a></span><a href="#method.as_total_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_total_slice" class="fnname">as_total_slice</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[</a>T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Access" title="type bitvec::store::BitStore::Access">Access</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></h4></section></summary><div class="docblock"><p>Accesses the underlying store, including contended partial elements.</p>
<p>This produces a slice of element wrappers that permit shared mutation,
rather than a slice of the bare <code>T</code> fundamentals.</p>
<h5 id="parameters-29"><a href="#parameters-29">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-22"><a href="#returns-22">Returns</a></h5>
<p>A slice of all elements under the bit span, including any
partially-owned edge elements, wrapped in safe shared-mutation types.</p>
</div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Add%3CBitVec%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#56-88">source</a></span><a href="#impl-Add%3CBitVec%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Add.html" title="trait core::ops::arith::Add">Add</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Adds two <code>BitVec</code>s together, zero-extending the shorter.</p>
<p><code>BitVec</code> addition works just like adding numbers longhand on paper. The first
bits in the <code>BitVec</code> are the highest, so addition works from right to left, and
the shorter <code>BitVec</code> is assumed to be extended to the left with zero.</p>
<p>The output <code>BitVec</code> may be one bit longer than the longer input, if addition
overflowed.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#84-87">source</a></span><a href="#method.add" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Add.html#tymethod.add" class="fnname">add</a>(self, addend: Self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Add.html#associatedtype.Output" title="type core::ops::arith::Add::Output">Output</a></h4></section></summary><div class="docblock"><p>Adds two <code>BitVec</code>s.</p>
<h5 id="examples-102"><a href="#examples-102">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">+</span> <span class="ident">b</span>;
<span class="macro">assert_eq!</span>(<span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="ident">s</span>);</code></pre></div>
<p>This example demonstrates the addition of differently-sized <code>BitVec</code>s,
and will overflow.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">b</span> <span class="op">+</span> <span class="ident">a</span>;
<span class="macro">assert_eq!</span>(<span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], <span class="ident">s</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CBitVec%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#105-142">source</a></span><a href="#impl-AddAssign%3CBitVec%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.AddAssign.html" title="trait core::ops::arith::AddAssign">AddAssign</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Adds another <code>BitVec</code> into <code>self</code>, zero-extending the shorter.</p>
<p><code>BitVec</code> addition works just like adding numbers longhand on paper. The first
bits in the <code>BitVec</code> are the highest, so addition works from right to left, and
the shorter <code>BitVec</code> is assumed to be extended to the left with zero.</p>
<p>The output <code>BitVec</code> may be one bit longer than the longer input, if addition
overflowed.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#119-141">source</a></span><a href="#method.add_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.AddAssign.html#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, addend: Self)</h4></section></summary><div class="docblock"><p>Adds another <code>BitVec</code> into <code>self</code>.</p>
<h5 id="examples-103"><a href="#examples-103">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="ident">a</span> <span class="op">+</span><span class="op">=</span> <span class="ident">b</span>;
<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3C%5BT%5D%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#323-328">source</a></span><a href="#impl-AsMut%3C%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Gives write access to all live elements in the underlying storage, including
the partially-filled tail.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#325-327">source</a></span><a href="#method.as_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;mut [T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#314-319">source</a></span><a href="#impl-AsMut%3CBitSlice%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#316-318">source</a></span><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3C%5BT%5D%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#339-354">source</a></span><a href="#impl-AsRef%3C%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Gives read access to all live elements in the underlying storage, including
the partially-filled tail.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#351-353">source</a></span><a href="#method.as_ref-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Accesses the underlying store.</p>
<h5 id="examples-125"><a href="#examples-125">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0b1000_0000</span>], <span class="ident">bv</span>.<span class="ident">as_slice</span>());</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#330-335">source</a></span><a href="#impl-AsRef%3CBitSlice%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#332-334">source</a></span><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Binary" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#430-435">source</a></span><a href="#impl-Binary" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#432-434">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Binary.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAnd%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#150-170">source</a></span><a href="#impl-BitAnd%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;I&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h3></section></summary><div class="docblock"><p>Performs the Boolean <code>AND</code> operation between each element of a <code>BitVec</code> and
anything that can provide a stream of <code>bool</code> values (such as another <code>BitVec</code>,
or any <code>bool</code> generator of your choice). The <code>BitVec</code> emitted will have the
length of the shorter sequence of bits – if one is longer than the other, the
extra bits will be ignored.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#166-169">source</a></span><a href="#method.bitand" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand" class="fnname">bitand</a>(self, rhs: I) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a></h4></section></summary><div class="docblock"><p><code>AND</code>s a vector and a bitstream, producing a new vector.</p>
<h5 id="examples-104"><a href="#examples-104">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">lhs</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">rhs</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">and</span> <span class="op">=</span> <span class="ident">lhs</span> <span class="op">&amp;</span> <span class="ident">rhs</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0001]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">and</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-1" class="type trait-impl has-srclink"><a href="#associatedtype.Output-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>&amp;</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#176-198">source</a></span><a href="#impl-BitAndAssign%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;I&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h3></section></summary><div class="docblock"><p>Performs the Boolean <code>AND</code> operation in place on a <code>BitVec</code>, using a stream
of <code>bool</code> values as the other bit for each operation. If the other stream is
shorter than <code>self</code>, <code>self</code> will be truncated when the other stream expires.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#189-197">source</a></span><a href="#method.bitand_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: I)</h4></section></summary><div class="docblock"><p><code>AND</code>s another bitstream into a vector.</p>
<h5 id="examples-105"><a href="#examples-105">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span>  <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
        <span class="ident">src</span> <span class="op">&amp;=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0001]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">src</span>));</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitField" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#830-851">source</a></span><a href="#impl-BitField" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="../fields/trait.BitField.html" title="trait bitvec::fields::BitField">BitField</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;: <a class="trait" href="../fields/trait.BitField.html" title="trait bitvec::fields::BitField">BitField</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_le" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#832-835">source</a></span><a href="#method.load_le" class="anchor"></a><h4 class="code-header">fn <a href="../fields/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;U&gt;(&amp;self) -&gt; U <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Load from <code>self</code>, using little-endian element ordering. <a href="../fields/trait.BitField.html#tymethod.load_le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_be" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#837-840">source</a></span><a href="#method.load_be" class="anchor"></a><h4 class="code-header">fn <a href="../fields/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;U&gt;(&amp;self) -&gt; U <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Load from <code>self</code>, using big-endian element ordering. <a href="../fields/trait.BitField.html#tymethod.load_be">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_le" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#842-845">source</a></span><a href="#method.store_le" class="anchor"></a><h4 class="code-header">fn <a href="../fields/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;U&gt;(&amp;mut self, value: U) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Store into <code>self</code>, using little-endian element ordering. <a href="../fields/trait.BitField.html#tymethod.store_le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_be" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#847-850">source</a></span><a href="#method.store_be" class="anchor"></a><h4 class="code-header">fn <a href="../fields/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;U&gt;(&amp;mut self, value: U) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Store into <code>self</code>, using big-endian element ordering. <a href="../fields/trait.BitField.html#tymethod.store_be">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#114-121">source</a></span><a href="#method.load" class="anchor"></a><h4 class="code-header">fn <a href="../fields/trait.BitField.html#method.load" class="fnname">load</a>&lt;U&gt;(&amp;self) -&gt; U <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Load the sequence of bits from <code>self</code> into the least-significant bits of
an element. <a href="../fields/trait.BitField.html#method.load">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/fields.rs.html#205-212">source</a></span><a href="#method.store" class="anchor"></a><h4 class="code-header">fn <a href="../fields/trait.BitField.html#method.store" class="fnname">store</a>&lt;U&gt;(&amp;mut self, value: U) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Stores a sequence of bits from the user into the domain of <code>self</code>. <a href="../fields/trait.BitField.html#method.store">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOr%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#206-226">source</a></span><a href="#impl-BitOr%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;I&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h3></section></summary><div class="docblock"><p>Performs the Boolean <code>OR</code> operation between each element of a <code>BitVec</code> and
anything that can provide a stream of <code>bool</code> values (such as another <code>BitVec</code>,
or any <code>bool</code> generator of your choice). The <code>BitVec</code> emitted will have the
length of the shorter sequence of bits – if one is longer than the other, the
extra bits will be ignored.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#222-225">source</a></span><a href="#method.bitor" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitOr.html#tymethod.bitor" class="fnname">bitor</a>(self, rhs: I) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a></h4></section></summary><div class="docblock"><p><code>OR</code>s a vector and a bitstream, producing a new vector.</p>
<h5 id="examples-106"><a href="#examples-106">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">lhs</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">rhs</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">or</span>  <span class="op">=</span> <span class="ident">lhs</span> <span class="op">|</span> <span class="ident">rhs</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">or</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-2" class="type trait-impl has-srclink"><a href="#associatedtype.Output-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>|</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#232-254">source</a></span><a href="#impl-BitOrAssign%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;I&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h3></section></summary><div class="docblock"><p>Performs the Boolean <code>OR</code> operation in place on a <code>BitVec</code>, using a stream
of <code>bool</code> values as the other bit for each operation. If the other stream is
shorter than <code>self</code>, <code>self</code> will be truncated when the other stream expires.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#245-253">source</a></span><a href="#method.bitor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: I)</h4></section></summary><div class="docblock"><p><code>OR</code>s another bitstream into a vector.</p>
<h5 id="examples-107"><a href="#examples-107">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span>  <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
        <span class="ident">src</span> <span class="op">|</span><span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">src</span>));</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXor%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#262-282">source</a></span><a href="#impl-BitXor%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;I&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h3></section></summary><div class="docblock"><p>Performs the Boolean <code>XOR</code> operation between each element of a <code>BitVec</code> and
anything that can provide a stream of <code>bool</code> values (such as another <code>BitVec</code>,
or any <code>bool</code> generator of your choice). The <code>BitVec</code> emitted will have the
length of the shorter sequence of bits – if one is longer than the other, the
extra bits will be ignored.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#278-281">source</a></span><a href="#method.bitxor" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor" class="fnname">bitxor</a>(self, rhs: I) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a></h4></section></summary><div class="docblock"><p><code>XOR</code>s a vector and a bitstream, producing a new vector.</p>
<h5 id="examples-108"><a href="#examples-108">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">lhs</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">rhs</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">xor</span> <span class="op">=</span> <span class="ident">lhs</span> <span class="op">^</span> <span class="ident">rhs</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0110]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">xor</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-3" class="type trait-impl has-srclink"><a href="#associatedtype.Output-3" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>^</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#288-310">source</a></span><a href="#impl-BitXorAssign%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;I&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></h3></section></summary><div class="docblock"><p>Performs the Boolean <code>XOR</code> operation in place on a <code>BitVec</code>, using a stream
of <code>bool</code> values as the other bit for each operation. If the other stream is
shorter than <code>self</code>, <code>self</code> will be truncated when the other stream expires.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#301-309">source</a></span><a href="#method.bitxor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: I)</h4></section></summary><div class="docblock"><p><code>XOR</code>s another bitstream into a vector.</p>
<h5 id="examples-109"><a href="#examples-109">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span>  <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
        <span class="ident">src</span> <span class="op">^</span><span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0110]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">src</span>));</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#44-69">source</a></span><a href="#impl-Borrow%3CBitSlice%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Signifies that <code>BitSlice</code> is the borrowed form of <code>BitVec</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#66-68">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Borrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<h5 id="parameters-31"><a href="#parameters-31">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
</ul>
<h5 id="returns-23"><a href="#returns-23">Returns</a></h5>
<p>A borrowed <code>BitSlice</code> of the vector.</p>
<h5 id="examples-121"><a href="#examples-121">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::borrow::Borrow</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">13</span>];
<span class="kw">let</span> <span class="ident">bs</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">borrow</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bs</span>[<span class="number">10</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#72-99">source</a></span><a href="#impl-BorrowMut%3CBitSlice%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Signifies that <code>BitSlice</code> is the borrowed form of <code>BitVec</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#96-98">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class="docblock"><p>Mutably borrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<h5 id="parameters-32"><a href="#parameters-32">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
</ul>
<h5 id="returns-24"><a href="#returns-24">Returns</a></h5>
<p>A mutably borrowed <code>BitSlice</code> of the vector.</p>
<h5 id="examples-122"><a href="#examples-122">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::borrow::BorrowMut</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">13</span>];
<span class="kw">let</span> <span class="ident">bs</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">bv</span>.<span class="ident">borrow_mut</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bs</span>[<span class="number">10</span>]);
<span class="ident">bs</span>.<span class="ident">set</span>(<span class="number">10</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(<span class="ident">bs</span>[<span class="number">10</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#101-133">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#103-114">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#116-132">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#448-473">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Prints the <code>BitVec</code> for debugging.</p>
<p>The output is of the form <code>BitVec&lt;O, T&gt; [ELT, *]</code>, where <code>&lt;O, T&gt;</code> is the order
and element type, with square brackets on each end of the bits and all the live
elements in the vector printed in binary. The printout is always in semantic
order, and may not reflect the underlying store. To see the underlying store,
use <code>format!(&quot;{:?}&quot;, self.as_slice());</code> instead.</p>
<p>The alternate character <code>{:#?}</code> prints each element on its own line, rather than
separated by a space.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#465-472">source</a></span><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class="docblock"><p>Renders the <code>BitVec</code> type header and contents for debug.</p>
<h5 id="examples-126"><a href="#examples-126">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Lsb0</span>, <span class="ident">u16</span>;
  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>
];
<span class="macro">assert_eq!</span>(
  <span class="string">&quot;BitVec&lt;Lsb0, u16&gt; [0101000011110101]&quot;</span>,
  <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">bv</span>)
);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#423-428">source</a></span><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#425-427">source</a></span><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class='docblock'><p>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.60.0/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Deref" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#316-334">source</a></span><a href="#impl-Deref" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Reborrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<p>This mimics the separation between <code>Vec&lt;T&gt;</code> and <code>[T]</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#331-333">source</a></span><a href="#method.deref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class="docblock"><p>Dereferences <code>&amp;BitVec</code> down to <code>&amp;BitSlice</code>.</p>
<h5 id="examples-110"><a href="#examples-110">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">bref</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">bv</span>;
<span class="macro">assert!</span>(<span class="ident">bref</span>[<span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target" class="type trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The resulting type after dereferencing.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-DerefMut" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#340-358">source</a></span><a href="#impl-DerefMut" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Mutably reborrows the <code>BitVec</code> as a <code>BitSlice</code>.</p>
<p>This mimics the separation between <code>Vec&lt;T&gt;</code> and <code>[T]</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#355-357">source</a></span><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class="docblock"><p>Dereferences <code>&amp;mut BitVec</code> down to <code>&amp;mut BitSlice</code>.</p>
<h5 id="examples-111"><a href="#examples-111">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let</span> <span class="ident">bref</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">bv</span>;
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bref</span>[<span class="number">5</span>]);
<span class="ident">bref</span>.<span class="ident">set</span>(<span class="number">5</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(<span class="ident">bref</span>[<span class="number">5</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#486-501">source</a></span><a href="#impl-Display" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Prints the <code>BitVec</code> for displaying.</p>
<p>This prints each element in turn, formatted in binary in semantic order (so the
first bit seen is printed first and the last bit seen printed last). Each
element of storage is separated by a space for ease of reading.</p>
<p>The alternate character <code>{:#}</code> prints each element on its own line.</p>
<p>To see the in-memory representation, use <code>AsRef</code> to get access to the raw
elements and print that slice instead.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#498-500">source</a></span><a href="#method.fmt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class="docblock"><p>Renders the <code>BitVec</code> contents for display.</p>
<h5 id="examples-127"><a href="#examples-127">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[01001011, 01]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Drop" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#361-370">source</a></span><a href="#impl-Drop" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Readies the underlying storage for Drop.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#364-369">source</a></span><a href="#method.drop" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Rebuild the interior <code>Vec</code> and let it run the deallocator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Extend%3Cbool%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#26-57">source</a></span><a href="#impl-Extend%3Cbool%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Extends a <code>BitVec</code> with the contents of another bitstream.</p>
<p>At present, this just calls <code>.push()</code> in a loop. When specialization becomes
available, it will be able to more intelligently perform bulk moves from the
source into <code>self</code> when the source is <code>BitSlice</code>-compatible.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#49-56">source</a></span><a href="#method.extend" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;&gt;(&amp;mut self, src: I)</h4></section></summary><div class="docblock"><p>Extends a <code>BitVec</code> from another bitstream.</p>
<h5 id="parameters-30"><a href="#parameters-30">Parameters</a></h5>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: A source bitstream.</li>
</ul>
<h5 id="type-parameters-1"><a href="#type-parameters-1">Type Parameters</a></h5>
<ul>
<li><code>I: IntoIterator&lt;Item=bool&gt;</code>: The source bitstream with which to
extend <code>self</code>.</li>
</ul>
<h5 id="examples-99"><a href="#examples-99">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">4</span>];
<span class="ident">bv</span>.<span class="ident">extend</span>(<span class="macro">bitvec!</span>[<span class="number">1</span>; <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(<span class="number">0x0F</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_one" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/iter/traits/collect.rs.html#363">source</a></span><a href="#method.extend_one" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>)</div></div><div class='docblock'><p>Extends a collection with exactly one element.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.extend_reserve" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/iter/traits/collect.rs.html#371">source</a></span><a href="#method.extend_reserve" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>extend_one</code>)</div></div><div class='docblock'><p>Reserves capacity in a collection for the given number of additional elements. <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.Extend.html#method.extend_reserve">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26%27_%20%5BT%5D%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#382-387">source</a></span><a href="#impl-From%3C%26%27_%20%5BT%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [T]</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#384-386">source</a></span><a href="#method.from-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[T]</a>) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26%27_%20%5Bbool%5D%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#368-373">source</a></span><a href="#impl-From%3C%26%27_%20%5Bbool%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Builds a <code>BitVec</code> out of a slice of <code>bool</code>.</p>
<p>This is primarily for the <code>bitvec!</code> macro; it is not recommended for general
use.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#370-372">source</a></span><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a><a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26%27_%20BitSlice%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#356-361">source</a></span><a href="#impl-From%3C%26%27_%20BitSlice%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;'_ <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#358-360">source</a></span><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitBox%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#375-380">source</a></span><a href="#impl-From%3CBitBox%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#377-379">source</a></span><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#165-170">source</a></span><a href="#impl-From%3CBitVec%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="../boxed/struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#167-169">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBox%3C%5BT%5D%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#389-394">source</a></span><a href="#impl-From%3CBox%3C%5BT%5D%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>, <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#391-393">source</a></span><a href="#method.from-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CVec%3CT%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#409-414">source</a></span><a href="#impl-From%3CVec%3CT%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Builds a <code>BitVec</code> out of a <code>Vec</code> of elements.</p>
<p>This moves the memory as-is from the source buffer into the new <code>BitVec</code>. The
source buffer will be unchanged by this operation, so you don’t need to worry
about using the correct order type.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#411-413">source</a></span><a href="#method.from-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(src: <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3Cbool%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#61-89">source</a></span><a href="#impl-FromIterator%3Cbool%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Permits the construction of a <code>BitVec</code> by using <code>.collect()</code> on an iterator
of <code>bool</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#77-88">source</a></span><a href="#method.from_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a>&gt;&gt;(src: I) -&gt; Self</h4></section></summary><div class="docblock"><p>Collects an iterator of <code>bool</code> into a vector.</p>
<h5 id="examples-100"><a href="#examples-100">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">use</span> <span class="ident">std::iter::repeat</span>;
<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">repeat</span>(<span class="bool-val">true</span>)
  .<span class="ident">take</span>(<span class="number">4</span>)
  .<span class="ident">chain</span>(<span class="ident">repeat</span>(<span class="bool-val">false</span>).<span class="ident">take</span>(<span class="number">4</span>))
  .<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>], <span class="number">0xF0</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#525-536">source</a></span><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Writes the contents of the <code>BitVec</code>, in semantic bit order, into a hasher.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#533-535">source</a></span><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, hasher: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>H)</h4></section></summary><div class="docblock"><p>Writes each bit of the <code>BitVec</code>, as a full <code>bool</code>, into the hasher.</p>
<h5 id="parameters-35"><a href="#parameters-35">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>hasher</code>: The hashing pool into which the vector is written.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.60.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRange%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#409-416">source</a></span><a href="#impl-Index%3CRange%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-5" class="type trait-impl has-srclink"><a href="#associatedtype.Output-5" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#413-415">source</a></span><a href="#method.index-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeFrom%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#425-432">source</a></span><a href="#impl-Index%3CRangeFrom%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-6" class="type trait-impl has-srclink"><a href="#associatedtype.Output-6" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#429-431">source</a></span><a href="#method.index-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeFull%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#441-448">source</a></span><a href="#impl-Index%3CRangeFull%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-7" class="type trait-impl has-srclink"><a href="#associatedtype.Output-7" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#445-447">source</a></span><a href="#method.index-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, _: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeInclusive%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#457-464">source</a></span><a href="#impl-Index%3CRangeInclusive%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-8" class="type trait-impl has-srclink"><a href="#associatedtype.Output-8" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#461-463">source</a></span><a href="#method.index-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeTo%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#473-480">source</a></span><a href="#impl-Index%3CRangeTo%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-9" class="type trait-impl has-srclink"><a href="#associatedtype.Output-9" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#477-479">source</a></span><a href="#method.index-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CRangeToInclusive%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#489-496">source</a></span><a href="#impl-Index%3CRangeToInclusive%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-10" class="type trait-impl has-srclink"><a href="#associatedtype.Output-10" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#493-495">source</a></span><a href="#method.index-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3Cusize%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#374-407">source</a></span><a href="#impl-Index%3Cusize%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Gets the bit at a specific index. The index must be less than the length of
the <code>BitVec</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#404-406">source</a></span><a href="#method.index" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, cursor: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class="docblock"><p>Looks up a single bit by semantic count.</p>
<h5 id="examples-112"><a href="#examples-112">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bv</span>[<span class="number">7</span>]); <span class="comment">// ---------------------------------^  |  |</span>
<span class="macro">assert!</span>( <span class="ident">bv</span>[<span class="number">8</span>]); <span class="comment">// ------------------------------------^  |</span>
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bv</span>[<span class="number">9</span>]); <span class="comment">// ---------------------------------------^</span></code></pre></div>
<p>If the index is greater than or equal to the length, indexing will
panic.</p>
<p>The below test will panic when accessing index 1, as only index 0 is
valid.</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span>: <span class="ident">BitVec</span> <span class="op">=</span> <span class="ident">BitVec::new</span>();
<span class="ident">bv</span>.<span class="ident">push</span>(<span class="bool-val">true</span>);
<span class="ident">bv</span>[<span class="number">1</span>];</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-4" class="type trait-impl has-srclink"><a href="#associatedtype.Output-4" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRange%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#418-423">source</a></span><a href="#impl-IndexMut%3CRange%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#420-422">source</a></span><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeFrom%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#434-439">source</a></span><a href="#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#436-438">source</a></span><a href="#method.index_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFrom.html" title="struct core::ops::range::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeFull%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#450-455">source</a></span><a href="#impl-IndexMut%3CRangeFull%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#452-454">source</a></span><a href="#method.index_mut-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, _: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeFull.html" title="struct core::ops::range::RangeFull">RangeFull</a>) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#466-471">source</a></span><a href="#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#468-470">source</a></span><a href="#method.index_mut-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeTo%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#482-487">source</a></span><a href="#impl-IndexMut%3CRangeTo%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#484-486">source</a></span><a href="#method.index_mut-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeTo.html" title="struct core::ops::range::RangeTo">RangeTo</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#498-503">source</a></span><a href="#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#500-502">source</a></span><a href="#method.index_mut-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, range: <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/ops/range/struct.RangeToInclusive.html" title="struct core::ops::range::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt;) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.60.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Into%3CBox%3C%5BT%5D%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#396-401">source</a></span><a href="#impl-Into%3CBox%3C%5BT%5D%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>, <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#398-400">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">[</a>T<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.slice.html">]</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Into%3CVec%3CT%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#416-421">source</a></span><a href="#impl-Into%3CVec%3CT%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T, <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#418-420">source</a></span><a href="#method.into-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#97-122">source</a></span><a href="#impl-IntoIterator" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Produces an iterator over all the bits in the vector.</p>
<p>This iterator follows the ordering in the vector type, and implements
<code>ExactSizeIterator</code>, since <code>BitVec</code>s always know exactly how large they are, and
<code>DoubleEndedIterator</code>, since they have known ends.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#116-121">source</a></span><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class="docblock"><p>Iterates over the vector.</p>
<h5 id="examples-101"><a href="#examples-101">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">for</span> <span class="ident">bit</span> <span class="kw">in</span> <span class="ident">bv</span> {
  <span class="kw">if</span> <span class="ident">bit</span> { <span class="ident">count</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>; }
}
<span class="macro">assert_eq!</span>(<span class="ident">count</span>, <span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="type trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct bitvec::vec::IntoIter">IntoIter</a>&lt;O, T&gt;</h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#124-132">source</a></span><a href="#impl-IntoIterator-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for &amp;'a <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item-1" class="type trait-impl has-srclink"><a href="#associatedtype.Item-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter-1" class="type trait-impl has-srclink"><a href="#associatedtype.IntoIter-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = &lt;&amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt; as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/iter.rs.html#129-131">source</a></span><a href="#method.into_iter-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.60.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-LowerHex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#503-508">source</a></span><a href="#impl-LowerHex" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#505-507">source</a></span><a href="#method.fmt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Neg" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#515-542">source</a></span><a href="#impl-Neg" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Neg.html" title="trait core::ops::arith::Neg">Neg</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>2’s-complement negation of a <code>BitVec</code>.</p>
<p>In 2’s-complement, negation is defined as bit-inversion followed by adding one.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.neg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#530-541">source</a></span><a href="#method.neg" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Neg.html#tymethod.neg" class="fnname">neg</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Neg.html#associatedtype.Output" title="type core::ops::arith::Neg::Output">Output</a></h4></section></summary><div class="docblock"><p>Numerically negates a <code>BitVec</code> using 2’s-complement arithmetic.</p>
<h5 id="examples-113"><a href="#examples-113">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ne</span> <span class="op">=</span> <span class="op">-</span><span class="ident">bv</span>;
<span class="macro">assert_eq!</span>(<span class="ident">ne</span>, <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-11" class="type trait-impl has-srclink"><a href="#associatedtype.Output-11" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Neg.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Not" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#545-564">source</a></span><a href="#impl-Not" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Flips all bits in the vector.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#560-563">source</a></span><a href="#method.not" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Not.html#tymethod.not" class="fnname">not</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></h4></section></summary><div class="docblock"><p>Inverts all bits in the vector.</p>
<h5 id="examples-114"><a href="#examples-114">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">BitVec::from</span>(<span class="kw-2">&amp;</span>[<span class="number">0u32</span>] <span class="kw">as</span> <span class="kw-2">&amp;</span>[<span class="ident">u32</span>]);
<span class="kw">let</span> <span class="ident">flip</span> <span class="op">=</span> <span class="op">!</span><span class="ident">bv</span>;
<span class="macro">assert_eq!</span>(<span class="op">!</span><span class="number">0u32</span>, <span class="ident">flip</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-12" class="type trait-impl has-srclink"><a href="#associatedtype.Output-12" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Not.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>!</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Octal" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#510-515">source</a></span><a href="#impl-Octal" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#512-514">source</a></span><a href="#method.fmt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Octal.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Ord" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#138-143">source</a></span><a href="#impl-Ord" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#140-142">source</a></span><a href="#method.cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, rhs: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'><p>This method returns an <a href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.max" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#796-798">source</a></span><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></section></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.min" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#816-818">source</a></span><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></section></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#841-843">source</a></span><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4></section></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#206-211">source</a></span><a href="#impl-PartialEq%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#208-210">source</a></span><a href="#method.eq-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#230">source</a></span><a href="#method.ne-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitSlice%3CC%2C%20D%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#192-197">source</a></span><a href="#impl-PartialEq%3CBitSlice%3CC%2C%20D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#194-196">source</a></span><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#230">source</a></span><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#152-190">source</a></span><a href="#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Tests if two <code>BitVec</code>s are semantically — not bitwise — equal.</p>
<p>It is valid to compare two vectors of different order or element types.</p>
<p>The equality condition requires that they have the same number of stored bits
and that each pair of bits in semantic order are identical.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#187-189">source</a></span><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Performs a comparison by <code>==</code>.</p>
<h5 id="parameters-33"><a href="#parameters-33">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>rhs</code>: The other vector to compare.</li>
</ul>
<h5 id="returns-25"><a href="#returns-25">Returns</a></h5>
<p>Whether the vectors compare equal.</p>
<h5 id="examples-123"><a href="#examples-123">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">l</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Lsb0</span>, <span class="ident">u16</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">r</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u32</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(<span class="ident">l</span> <span class="op">==</span> <span class="ident">r</span>);</code></pre></div>
<p>This example uses the same types to prove that raw, bitwise, values are
not used for equality comparison.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">l</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">r</span>: <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Lsb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="macro">assert_eq!</span>(<span class="ident">l</span>, <span class="ident">r</span>);
<span class="macro">assert_ne!</span>(<span class="ident">l</span>.<span class="ident">as_slice</span>(), <span class="ident">r</span>.<span class="ident">as_slice</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#230">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#199-204">source</a></span><a href="#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#201-203">source</a></span><a href="#method.eq-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#230">source</a></span><a href="#method.ne-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#220-225">source</a></span><a href="#impl-PartialEq%3CBitVec%3CC%2C%20D%3E%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#222-224">source</a></span><a href="#method.eq-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#230">source</a></span><a href="#method.ne-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#286-291">source</a></span><a href="#impl-PartialOrd%3C%26%27_%20BitSlice%3CC%2C%20D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;&amp;'_ <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#288-290">source</a></span><a href="#method.partial_cmp-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;&amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1104">source</a></span><a href="#method.lt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1124">source</a></span><a href="#method.le-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1147">source</a></span><a href="#method.gt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1167">source</a></span><a href="#method.ge-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitSlice%3CC%2C%20D%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#272-277">source</a></span><a href="#impl-PartialOrd%3CBitSlice%3CC%2C%20D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#274-276">source</a></span><a href="#method.partial_cmp-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1104">source</a></span><a href="#method.lt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1124">source</a></span><a href="#method.le-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1147">source</a></span><a href="#method.gt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1167">source</a></span><a href="#method.ge-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#243-270">source</a></span><a href="#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Compares two <code>BitVec</code>s by semantic — not bitwise — ordering.</p>
<p>The comparison sorts by testing each index for one vector to have a set bit
where the other vector has an unset bit. If the vectors are different, the
vector with the set bit sorts greater than the vector with the unset bit.</p>
<p>If one of the vectors is exhausted before they differ, the longer vector is
greater.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#267-269">source</a></span><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class="docblock"><p>Performs a comparison by <code>&lt;</code> or <code>&gt;</code>.</p>
<h5 id="parameters-34"><a href="#parameters-34">Parameters</a></h5>
<ul>
<li><code>&amp;self</code></li>
<li><code>rhs</code>: The other vector to compare.</li>
</ul>
<h5 id="returns-26"><a href="#returns-26">Returns</a></h5>
<p>The relative ordering of the two vectors.</p>
<h5 id="examples-124"><a href="#examples-124">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert!</span>(<span class="ident">a</span> <span class="op">&lt;</span> <span class="ident">b</span>);
<span class="macro">assert!</span>(<span class="ident">b</span> <span class="op">&lt;</span> <span class="ident">c</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1104">source</a></span><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1124">source</a></span><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1147">source</a></span><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1167">source</a></span><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#279-284">source</a></span><a href="#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#281-283">source</a></span><a href="#method.partial_cmp-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1104">source</a></span><a href="#method.lt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1124">source</a></span><a href="#method.le-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1147">source</a></span><a href="#method.gt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1167">source</a></span><a href="#method.ge-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#293-298">source</a></span><a href="#impl-PartialOrd%3CBitVec%3CC%2C%20D%3E%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, B, C, D&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;&gt; for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;A, B&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#295-297">source</a></span><a href="#method.partial_cmp-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, rhs: &amp;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;C, D&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.60.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1104">source</a></span><a href="#method.lt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1124">source</a></span><a href="#method.le-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1147">source</a></span><a href="#method.gt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-4" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/cmp.rs.html#1167">source</a></span><a href="#method.ge-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Shl%3Cusize%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#597-621">source</a></span><a href="#impl-Shl%3Cusize%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shl.html" title="trait core::ops::bit::Shl">Shl</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Shifts all bits in the vector to the left – <strong>DOWN AND TOWARDS THE FRONT</strong>.</p>
<p>On fundamentals, the left-shift operator <code>&lt;&lt;</code> moves bits away from origin and
towards the ceiling. This is because we label the bits in a primitive with the
minimum on the right and the maximum on the left, which is big-endian bit order.
This increases the value of the primitive being shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on the
right! Thus, left-shifting moves bits towards the <strong>minimum</strong>.</p>
<p>In <code>Msb0</code> order, the effect in memory will be what you expect the <code>&lt;&lt;</code> operator
to do.</p>
<p><strong>In <code>Lsb0</code> order, the effect will be equivalent to using <code>&gt;&gt;</code> on the</strong>
<strong>fundamentals in memory!</strong></p>
<h4 id="notes-5"><a href="#notes-5">Notes</a></h4>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than
left to their old value.</p>
<p>The length of the vector is decreased by the shift amount.</p>
<p>If the shift amount is greater than the length, the vector calls <code>clear()</code> and
zeroes its memory. This is <em>not</em> an error.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shl" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#617-620">source</a></span><a href="#method.shl" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shl.html#tymethod.shl" class="fnname">shl</a>(self, shamt: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shl.html#associatedtype.Output" title="type core::ops::bit::Shl::Output">Output</a></h4></section></summary><div class="docblock"><p>Shifts a <code>BitVec</code> to the left, shortening it.</p>
<h5 id="examples-115"><a href="#examples-115">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0001_1100</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="kw">let</span> <span class="ident">ls</span> <span class="op">=</span> <span class="ident">bv</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="number">2usize</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">ls</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0111_0000</span>, <span class="ident">ls</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">ls</span>.<span class="ident">len</span>(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-13" class="type trait-impl has-srclink"><a href="#associatedtype.Output-13" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shl.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>&lt;&lt;</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ShlAssign%3Cusize%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#652-687">source</a></span><a href="#impl-ShlAssign%3Cusize%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.ShlAssign.html" title="trait core::ops::bit::ShlAssign">ShlAssign</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Shifts all bits in the vector to the left – <strong>DOWN AND TOWARDS THE FRONT</strong>.</p>
<p>On fundamentals, the left-shift operator <code>&lt;&lt;</code> moves bits away from origin and
towards the ceiling. This is because we label the bits in a primitive with the
minimum on the right and the maximum on the left, which is big-endian bit order.
This increases the value of the primitive being shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on the
right! Thus, left-shifting moves bits towards the <strong>minimum</strong>.</p>
<p>In <code>Msb0</code> order, the effect in memory will be what you expect the <code>&lt;&lt;</code> operator
to do.</p>
<p><strong>In <code>Lsb0</code> order, the effect will be equivalent to using <code>&gt;&gt;</code> on the</strong>
<strong>fundamentals in memory!</strong></p>
<h4 id="notes-6"><a href="#notes-6">Notes</a></h4>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than left
to their old value.</p>
<p>The length of the vector is decreased by the shift amount.</p>
<p>If the shift amount is greater than the length, the vector calls <code>clear()</code> and
zeroes its memory. This is <em>not</em> an error.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shl_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#670-686">source</a></span><a href="#method.shl_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.ShlAssign.html#tymethod.shl_assign" class="fnname">shl_assign</a>(&amp;mut self, shamt: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts a <code>BitVec</code> to the left in place, shortening it.</p>
<h5 id="examples-116"><a href="#examples-116">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Lsb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0011_1000</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="ident">bv</span> <span class="op">&lt;</span><span class="op">&lt;</span><span class="op">=</span> <span class="number">2</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[0111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0000_1110</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">4</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Shr%3Cusize%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#718-743">source</a></span><a href="#impl-Shr%3Cusize%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shr.html" title="trait core::ops::bit::Shr">Shr</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Shifts all bits in the vector to the right – <strong>UP AND TOWARDS THE BACK</strong>.</p>
<p>On fundamentals, the right-shift operator <code>&gt;&gt;</code> moves bits towards the origin and
away from the ceiling. This is because we label the bits in a primitive with the
minimum on the right and the maximum on the left, which is big-endian bit order.
This decreases the value of the primitive being shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on the
right! Thus, right-shifting moves bits towards the <strong>maximum</strong>.</p>
<p>In <code>Msb0</code> order, the effect in memory will be what you expect the <code>&gt;&gt;</code> operator
to do.</p>
<p><strong>In <code>Lsb0</code> order, the effect will be equivalent to using <code>&lt;&lt;</code> on the</strong>
<strong>fundamentals in memory!</strong></p>
<h4 id="notes-7"><a href="#notes-7">Notes</a></h4>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than left
to their old value.</p>
<p>The length of the vector is increased by the shift amount.</p>
<p>If the new length of the vector would overflow, a panic occurs. This <em>is</em> an
error.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shr" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#739-742">source</a></span><a href="#method.shr" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shr.html#tymethod.shr" class="fnname">shr</a>(self, shamt: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shr.html#associatedtype.Output" title="type core::ops::bit::Shr::Output">Output</a></h4></section></summary><div class="docblock"><p>Shifts a <code>BitVec</code> to the right, lengthening it and filling the front
with 0.</p>
<h5 id="examples-117"><a href="#examples-117">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0001_1100</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="kw">let</span> <span class="ident">rs</span> <span class="op">=</span> <span class="ident">bv</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="number">2usize</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[00000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">rs</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0000_0111</span>, <span class="ident">rs</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">rs</span>.<span class="ident">len</span>(), <span class="number">8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-14" class="type trait-impl has-srclink"><a href="#associatedtype.Output-14" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.Shr.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>&gt;&gt;</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ShrAssign%3Cusize%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#774-806">source</a></span><a href="#impl-ShrAssign%3Cusize%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.ShrAssign.html" title="trait core::ops::bit::ShrAssign">ShrAssign</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Shifts all bits in the vector to the right – <strong>UP AND TOWARDS THE BACK</strong>.</p>
<p>On fundamentals, the right-shift operator <code>&gt;&gt;</code> moves bits towards the origin and
away from the ceiling. This is because we label the bits in a primitive with the
minimum on the right and the maximum on the left, which is big-endian bit order.
This decreases the value of the primitive being shifted.</p>
<p><strong>THAT IS NOT HOW <code>BITVEC</code> WORKS!</strong></p>
<p><code>BitVec</code> defines its layout with the minimum on the left and the maximum on the
right! Thus, right-shifting moves bits towards the <strong>maximum</strong>.</p>
<p>In <code>Msb0</code> order, the effect in memory will be what you expect the <code>&gt;&gt;</code> operator
to do.</p>
<p><strong>In <code>Lsb0</code> order, the effect will be equivalent to using <code>&lt;&lt;</code> on the</strong>
<strong>fundamentals in memory!</strong></p>
<h4 id="notes-8"><a href="#notes-8">Notes</a></h4>
<p>In order to preserve the effects in memory that this operator traditionally
expects, the bits that are emptied by this operation are zeroed rather than left
to their old value.</p>
<p>The length of the vector is increased by the shift amount.</p>
<p>If the new length of the vector would overflow, a panic occurs. This <em>is</em> an
error.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shr_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#793-805">source</a></span><a href="#method.shr_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/bit/trait.ShrAssign.html#tymethod.shr_assign" class="fnname">shr_assign</a>(&amp;mut self, shamt: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts a <code>BitVec</code> to the right in place, lengthening it and filling the
front with 0.</p>
<h5 id="examples-118"><a href="#examples-118">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bv</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="ident">Lsb0</span>, <span class="ident">u8</span>; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;[000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b0011_1000</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">6</span>);
<span class="ident">bv</span> <span class="op">&gt;</span><span class="op">&gt;</span><span class="op">=</span> <span class="number">2</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;[00000111]&quot;</span>, <span class="kw-2">&amp;</span><span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">bv</span>));
<span class="macro">assert_eq!</span>(<span class="number">0b1110_0000</span>, <span class="ident">bv</span>.<span class="ident">as_slice</span>()[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bv</span>.<span class="ident">len</span>(), <span class="number">8</span>);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Sub%3CBitVec%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#836-880">source</a></span><a href="#impl-Sub%3CBitVec%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Sub.html" title="trait core::ops::arith::Sub">Sub</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Subtracts one <code>BitVec</code> from another assuming 2’s-complement encoding.</p>
<p>Subtraction is a more complex operation than addition. The bit-level work is
largely the same, but semantic distinctions must be made. Unlike addition, which
is commutative and tolerant of switching the order of the addends, subtraction
cannot swap the minuend (LHS) and subtrahend (RHS).</p>
<p>Because of the properties of 2’s-complement arithmetic, M - S is equivalent to M</p>
<ul>
<li>(!S + 1). Subtraction therefore bitflips the subtrahend and adds one. This
may, in a degenerate case, cause the subtrahend to increase in length.</li>
</ul>
<p>Once the subtrahend is stable, the minuend zero-extends its left side in order
to match the length of the subtrahend if needed (this is provided by the <code>&gt;&gt;</code>
operator).</p>
<p>When the minuend is stable, the minuend and subtrahend are added together by the
<code>&lt;BitVec as Add&gt;</code> implementation. The output will be encoded in 2’s-complement,
so a leading one means that the output is considered negative.</p>
<p>Interpreting the contents of a <code>BitVec</code> as an integer is beyond the scope of
this crate.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#876-879">source</a></span><a href="#method.sub" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Sub.html#tymethod.sub" class="fnname">sub</a>(self, subtrahend: Self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Sub.html#associatedtype.Output" title="type core::ops::arith::Sub::Output">Output</a></h4></section></summary><div class="docblock"><p>Subtracts one <code>BitVec</code> from another.</p>
<h5 id="examples-119"><a href="#examples-119">Examples</a></h5>
<p>Minuend larger than subtrahend, positive difference.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[   <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert_eq!</span>(<span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>], <span class="ident">c</span>);</code></pre></div>
<p>Minuend smaller than subtrahend, negative difference.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[   <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert_eq!</span>(<span class="macro">bitvec!</span>[<span class="number">1</span>, <span class="number">1</span>], <span class="ident">c</span>);</code></pre></div>
<p>Subtraction from self is correctly handled.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">clone</span>();
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert!</span>(<span class="ident">c</span>.<span class="ident">not_any</span>(), <span class="string">&quot;{:?}&quot;</span>, <span class="ident">c</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-15" class="type trait-impl has-srclink"><a href="#associatedtype.Output-15" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = Self</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>-</code> operator.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CBitVec%3CO%2C%20T%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#895-941">source</a></span><a href="#impl-SubAssign%3CBitVec%3CO%2C%20T%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.SubAssign.html" title="trait core::ops::arith::SubAssign">SubAssign</a>&lt;<a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt;&gt; for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p>Subtracts another <code>BitVec</code> from <code>self</code>, assuming 2’s-complement encoding.</p>
<p>The minuend is zero-extended, or the subtrahend sign-extended, as needed to
ensure that the vectors are the same width before subtraction occurs.</p>
<p>The <code>Sub</code> trait has more documentation on the subtraction process.</p>
<p>Numeric arithmetic is provided on <code>BitVec</code> as a convenience. Serious numeric
computation on variable-length integers should use the <code>num_bigint</code> crate
instead, which is written specifically for that use case. <code>BitVec</code>s are not
intended for arithmetic, and <code>bitvec</code> makes no guarantees about sustained
correctness in arithmetic at this time.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/ops.rs.html#910-940">source</a></span><a href="#method.sub_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/ops/arith/trait.SubAssign.html#tymethod.sub_assign" class="fnname">sub_assign</a>(&amp;mut self, subtrahend: Self)</h4></section></summary><div class="docblock"><p>Subtracts another <code>BitVec</code> from <code>self</code>.</p>
<h5 id="examples-120"><a href="#examples-120">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">-</span> <span class="ident">b</span>;
<span class="macro">assert_eq!</span>(<span class="ident">c</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-UpperHex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#517-522">source</a></span><a href="#impl-UpperHex" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#519-521">source</a></span><a href="#method.fmt-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.60.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><section id="impl-Eq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#135-136">source</a></span><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section><section id="impl-Send" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#539-540">source</a></span><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section><div class="docblock"><p><code>BitVec</code> is safe to move across thread boundaries, as is <code>&amp;mut BitVec</code>.</p>
</div><section id="impl-Sync" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#543-544">source</a></span><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section><div class="docblock"><p><code>&amp;BitVec</code> is safe to move across thread boundaries.</p>
</div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;O, T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;O, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,&nbsp;</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.60.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.60.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#553-558">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#555">source</a></span><a href="#method.from-7" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#537-548">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#545">source</a></span><a href="#method.into-2" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#84-96">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#89">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/borrow.rs.html#93">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.60.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.60.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-ToString" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/string.rs.html#2395-2409">source</a></span><a href="#impl-ToString" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.60.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/alloc/string.rs.html#2401">source</a></span><a href="#method.to_string" class="anchor"></a><h4 class="code-header">pub default fn <a href="https://doc.rust-lang.org/1.60.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.60.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.60.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#594-603">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#600">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#579-588">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.60.0/src/core/convert/mod.rs.html#585">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.60.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.60.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0 (7737e0b5c 2022-04-04)" ></div>
</body></html>